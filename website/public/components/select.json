{
  "type": "component",
  "fileDependencies": [
    "./box",
    "./popover",
    "./visually-hidden"
  ],
  "id": "select",
  "file": {
    "name": "select.tsx",
    "content": "\"use client\";\r\n\r\nimport {\r\n    type FocusableElement,\r\n    SelectDescendantsProvider,\r\n    SelectProvider,\r\n    type UseSelectItemProps,\r\n    type UseSelectProps,\r\n    useHiddenSelect,\r\n    useSafeLayoutEffect,\r\n    useSelect,\r\n    useSelectContext,\r\n    useSelectItem\r\n} from \"@dreamy-ui/react\";\r\nimport { useVirtualizer } from \"@tanstack/react-virtual\";\r\nimport type React from \"react\";\r\nimport {\r\n    Children,\r\n    type ReactNode,\r\n    type RefObject,\r\n    type SVGProps,\r\n    forwardRef,\r\n    useRef,\r\n    useState\r\n} from \"react\";\r\nimport { type HTMLDreamyProps, createStyleContext, dreamy, splitCssProps } from \"styled-system/jsx\";\r\nimport { select } from \"styled-system/recipes\";\r\nimport { Box } from \"./box\";\r\nimport { Popover, type PopoverContentProps, type PopoverProps } from \"./popover\";\r\nimport { VisuallyHidden } from \"./visually-hidden\";\r\n\r\nconst { withProvider, withContext } = createStyleContext(select);\r\n\r\nexport interface HiddenSelectProps {\r\n    placeholder: string;\r\n    multiple: boolean;\r\n    autoComplete: string;\r\n    triggerRef: RefObject<FocusableElement | null>;\r\n    domRef: RefObject<HTMLSelectElement | null>;\r\n    onChange?: (e: React.ChangeEvent<HTMLSelectElement>) => void;\r\n    onChangeValue?: (value: string | string[]) => void;\r\n}\r\n\r\nfunction HiddenSelect(props: HiddenSelectProps) {\r\n    const { domRef, placeholder } = props;\r\n\r\n    const { containerProps, selectProps, descendants, id, selectedKeys } = useHiddenSelect({\r\n        ...props,\r\n        domRef\r\n    });\r\n\r\n    const [, forceUpdate] = useState({});\r\n\r\n    useSafeLayoutEffect(() => {\r\n        forceUpdate({});\r\n    }, []);\r\n\r\n    const items = Array.from(descendants.values());\r\n\r\n    return (\r\n        <VisuallyHidden {...containerProps}>\r\n            <label>\r\n                {placeholder}\r\n                <select\r\n                    {...selectProps}\r\n                    ref={domRef}\r\n                >\r\n                    <option />\r\n                    {items.map((item: any) => {\r\n                        const isSelected = selectProps.multiple\r\n                            ? selectedKeys.includes(item.node.value)\r\n                            : undefined;\r\n\r\n                        return (\r\n                            <option\r\n                                key={`${id}-${item.node.value}`}\r\n                                selected={isSelected}\r\n                                value={item.node.value}\r\n                            >\r\n                                {item.textValue}\r\n                            </option>\r\n                        );\r\n                    })}\r\n                </select>\r\n            </label>\r\n        </VisuallyHidden>\r\n    );\r\n}\r\n\r\nexport interface SelectProps<T extends boolean>\r\n    extends UseSelectProps<T, PopoverProps>,\r\n        Omit<HTMLDreamyProps<\"div\">, keyof UseSelectProps<T, PopoverProps>> {\r\n    children?: ReactNode;\r\n}\r\n\r\n/**\r\n * Select component\r\n *\r\n * @See Docs https://dreamy-ui.com/docs/components/select\r\n */\r\nconst SelectRoot: <T extends boolean = false>(props: SelectProps<T>) => React.JSX.Element =\r\n    withProvider(function SelectRoot<T extends boolean = false>({\r\n        children,\r\n        ...props\r\n    }: SelectProps<T>) {\r\n        const [cssProps, restProps] = splitCssProps(props);\r\n        const ctx = useSelect<T, PopoverProps>(restProps);\r\n\r\n        return (\r\n            <SelectProvider value={ctx as any}>\r\n                <Box\r\n                    {...ctx.getRootProps({\r\n                        ...cssProps,\r\n                        className: restProps.className\r\n                    })}\r\n                >\r\n                    <HiddenSelect {...ctx.getHiddenSelectProps()} />\r\n                    <Popover.Root\r\n                        hasArrow={false}\r\n                        initialFocusRef={ctx.triggerRef}\r\n                        isOpen={ctx.isOpen}\r\n                        lazyBehavior=\"keepMounted\"\r\n                        onClose={ctx.onClose}\r\n                        onOpen={ctx.onOpen}\r\n                        placement=\"bottom\"\r\n                        reduceMotion={ctx.reduceMotion}\r\n                        {...props.popoverProps}\r\n                    >\r\n                        <SelectDescendantsProvider value={ctx.descendants}>\r\n                            {children}\r\n                        </SelectDescendantsProvider>\r\n                    </Popover.Root>\r\n                </Box>\r\n            </SelectProvider>\r\n        );\r\n    }, \"root\") as any;\r\n\r\nexport interface SelectTriggerProps extends HTMLDreamyProps<\"button\"> {\r\n    /**\r\n     * Icon to show in the trigger.\r\n     */\r\n    icon?: React.ReactNode;\r\n    /**\r\n     * Placeholder text to show when no item is selected.\r\n     */\r\n    placeholder?: string;\r\n    /**\r\n     * Text to show when multiple items are selected.\r\n     */\r\n    multipleSelectedText?: (selectedKeys: string[]) => string;\r\n}\r\n\r\nconst SelectTrigger = withContext(\r\n    forwardRef<HTMLButtonElement, SelectTriggerProps>(function SelectTrigger(\r\n        {\r\n            children,\r\n            placeholder,\r\n            icon,\r\n            multipleSelectedText = (selectedKeys) => `${selectedKeys.length} Selected`,\r\n            ...rest\r\n        },\r\n        ref\r\n    ) {\r\n        const { getTriggerProps, selectedKeys, descendants, isClearable } = useSelectContext();\r\n\r\n        const selectedNames = selectedKeys.map((key) => {\r\n            const item: any = Array.from(descendants.values()).find((node: any) => {\r\n                return node.node.value === key;\r\n            });\r\n            return item?.textValue;\r\n        });\r\n\r\n        const [, forceUpdate] = useState({});\r\n\r\n        useSafeLayoutEffect(() => {\r\n            forceUpdate({});\r\n        }, [JSON.stringify(Array.from(descendants.values()).map((node: any) => node.node.value))]);\r\n\r\n        return (\r\n            <>\r\n                <Popover.Trigger>\r\n                    <dreamy.button {...(getTriggerProps(rest, ref) as any)}>\r\n                        {icon && icon}\r\n\r\n                        <span>\r\n                            {selectedNames.length === 1\r\n                                ? selectedNames[0]\r\n                                : selectedNames.length > 1\r\n                                  ? multipleSelectedText(selectedNames)\r\n                                  : placeholder}\r\n                        </span>\r\n                        <SelectIndicatorGroup>\r\n                            {isClearable && selectedKeys.length > 0 && <SelectClearButton />}\r\n                            <SelectIndicator />\r\n                        </SelectIndicatorGroup>\r\n                    </dreamy.button>\r\n                </Popover.Trigger>\r\n            </>\r\n        );\r\n    }),\r\n    \"trigger\"\r\n);\r\n\r\nexport interface SelectContentProps extends PopoverContentProps {}\r\n\r\nconst SelectContent = withContext(\r\n    forwardRef<HTMLDivElement, SelectContentProps>(function SelectContent(props, ref) {\r\n        const { children, ...rest } = props;\r\n        const { getContentProps } = useSelectContext();\r\n        const contentPropsResult = getContentProps(rest, ref);\r\n\r\n        return <Popover.Content {...contentPropsResult}>{children}</Popover.Content>;\r\n    }),\r\n    \"content\"\r\n);\r\n\r\nexport interface SelectVirtualContentProps extends PopoverContentProps {\r\n    /**\r\n     * Estimated height of each item in pixels.\r\n     * Used for virtualization calculations.\r\n     * @default 32\r\n     */\r\n    estimatedItemHeight?: number;\r\n    /**\r\n     * Number of items to render outside the visible area.\r\n     * Higher values reduce flickering during fast scrolling but increase initial render cost.\r\n     * @default 5\r\n     */\r\n    overscan?: number;\r\n    /**\r\n     * Maximum height of the virtualized list container in pixels.\r\n     * @default 300\r\n     */\r\n    maxHeight?: number;\r\n}\r\n\r\n/**\r\n * Virtualized SelectContent for better performance with large lists.\r\n * Only renders visible items.\r\n */\r\nconst SelectVirtualContent = withContext(\r\n    forwardRef<HTMLDivElement, SelectVirtualContentProps>(function SelectVirtualContent(props, ref) {\r\n        const {\r\n            children,\r\n            estimatedItemHeight = 32,\r\n            overscan = 5,\r\n            maxHeight = 300,\r\n            ...rest\r\n        } = props;\r\n\r\n        const { getContentProps, isOpen, selectedKeys } = useSelectContext();\r\n        const contentPropsResult = getContentProps(rest, ref);\r\n\r\n        return (\r\n            <Popover.Content {...contentPropsResult}>\r\n                <VirtualizedList\r\n                    estimatedItemHeight={estimatedItemHeight}\r\n                    isOpen={isOpen}\r\n                    maxHeight={maxHeight}\r\n                    overscan={overscan}\r\n                    selectedKeys={selectedKeys}\r\n                >\r\n                    {children}\r\n                </VirtualizedList>\r\n            </Popover.Content>\r\n        );\r\n    }),\r\n    \"content\"\r\n);\r\n\r\ninterface VirtualizedListProps {\r\n    children: ReactNode;\r\n    estimatedItemHeight: number;\r\n    overscan: number;\r\n    maxHeight: number;\r\n    isOpen: boolean;\r\n    selectedKeys: string[];\r\n}\r\n\r\nfunction VirtualizedList({\r\n    children,\r\n    estimatedItemHeight,\r\n    overscan,\r\n    maxHeight,\r\n    isOpen,\r\n    selectedKeys\r\n}: VirtualizedListProps) {\r\n    const scrollContainerRef = useRef<HTMLDivElement>(null);\r\n    const childArray = Children.toArray(children);\r\n    const [hasMeasured, setHasMeasured] = useState(false);\r\n\r\n    const virtualizer = useVirtualizer({\r\n        count: childArray.length,\r\n        getScrollElement: () => scrollContainerRef.current,\r\n        estimateSize: () => estimatedItemHeight,\r\n        overscan\r\n    });\r\n\r\n    // Force remeasure when popover opens\r\n    useSafeLayoutEffect(() => {\r\n        if (isOpen && scrollContainerRef.current) {\r\n            // Use requestAnimationFrame to ensure the DOM has fully painted\r\n            requestAnimationFrame(() => {\r\n                virtualizer.measure();\r\n                setHasMeasured(true);\r\n            });\r\n        }\r\n    }, [isOpen, virtualizer]);\r\n\r\n    const virtualItems = virtualizer.getVirtualItems();\r\n    const totalSize = virtualizer.getTotalSize();\r\n\r\n    // Find indices of selected items to always render them\r\n    const selectedIndices = new Set<number>();\r\n    childArray.forEach((child, index) => {\r\n        if (\r\n            child &&\r\n            typeof child === \"object\" &&\r\n            \"props\" in child &&\r\n            selectedKeys.includes((child as React.ReactElement<{ value: string }>).props.value)\r\n        ) {\r\n            selectedIndices.add(index);\r\n        }\r\n    });\r\n\r\n    // Get the set of indices that are already being rendered by virtualizer\r\n    const virtualizedIndices = new Set(virtualItems.map((item) => item.index));\r\n\r\n    // Find selected items that are NOT in the virtualized view\r\n    const hiddenSelectedIndices = Array.from(selectedIndices).filter(\r\n        (index) => !virtualizedIndices.has(index)\r\n    );\r\n\r\n    // If we haven't measured yet but we're open, show initial items as fallback\r\n    const showFallback = isOpen && !hasMeasured && virtualItems.length === 0 && childArray.length > 0;\r\n    const initialItemsToShow = Math.min(Math.ceil(maxHeight / estimatedItemHeight) + overscan, childArray.length);\r\n\r\n    return (\r\n        <div\r\n            ref={scrollContainerRef}\r\n            style={{\r\n                maxHeight,\r\n                overflowY: \"auto\",\r\n                width: \"100%\"\r\n            }}\r\n        >\r\n            <div\r\n                style={{\r\n                    height: showFallback ? childArray.length * estimatedItemHeight : totalSize,\r\n                    width: \"100%\",\r\n                    position: \"relative\"\r\n                }}\r\n            >\r\n                {showFallback\r\n                    ? childArray.slice(0, initialItemsToShow).map((child, index) => (\r\n                          <div\r\n                              key={index}\r\n                              style={{\r\n                                  position: \"absolute\",\r\n                                  top: 0,\r\n                                  left: 0,\r\n                                  width: \"100%\",\r\n                                  transform: `translateY(${index * estimatedItemHeight}px)`\r\n                              }}\r\n                          >\r\n                              {child}\r\n                          </div>\r\n                      ))\r\n                    : virtualItems.map((virtualItem) => (\r\n                          <div\r\n                              key={virtualItem.key}\r\n                              data-index={virtualItem.index}\r\n                              ref={virtualizer.measureElement}\r\n                              style={{\r\n                                  position: \"absolute\",\r\n                                  top: 0,\r\n                                  left: 0,\r\n                                  width: \"100%\",\r\n                                  transform: `translateY(${virtualItem.start}px)`\r\n                              }}\r\n                          >\r\n                              {childArray[virtualItem.index]}\r\n                          </div>\r\n                      ))}\r\n\r\n                {/* Always render selected items that are outside the virtualized view (hidden but mounted for descendants registration) */}\r\n                {!showFallback &&\r\n                    hiddenSelectedIndices.map((index) => (\r\n                        <div\r\n                            key={`selected-${index}`}\r\n                            aria-hidden=\"true\"\r\n                            style={{\r\n                                position: \"absolute\",\r\n                                top: 0,\r\n                                left: 0,\r\n                                width: \"100%\",\r\n                                pointerEvents: \"none\",\r\n                                visibility: \"hidden\"\r\n                            }}\r\n                        >\r\n                            {childArray[index]}\r\n                        </div>\r\n                    ))}\r\n            </div>\r\n        </div>\r\n    );\r\n}\r\n\r\nexport interface SelectItemProps extends UseSelectItemProps {}\r\n\r\n/**\r\n * @internal\r\n */\r\nconst SelectIndicatorGroup = withContext(Box, \"indicatorGroup\");\r\n\r\nconst CheckIcon = forwardRef<SVGSVGElement, SVGProps<SVGSVGElement>>(\r\n    function CheckIcon(props, ref) {\r\n        return (\r\n            <svg\r\n                aria-hidden=\"true\"\r\n                fill=\"none\"\r\n                height=\"16\"\r\n                stroke=\"currentColor\"\r\n                strokeLinecap=\"round\"\r\n                strokeLinejoin=\"round\"\r\n                strokeWidth=\"2\"\r\n                viewBox=\"0 0 24 24\"\r\n                width=\"16\"\r\n                {...props}\r\n                ref={ref}\r\n            >\r\n                <path d=\"m6 9 6 6 6-6\" />\r\n            </svg>\r\n        );\r\n    }\r\n);\r\n\r\nconst SelectItemIndicator = withContext(CheckIcon, \"itemIndicator\");\r\nconst SelectItem = withContext(\r\n    forwardRef<HTMLDivElement, SelectItemProps>(function SelectItem(props, ref) {\r\n        const { selectedStrategy, selectedKeys } = useSelectContext();\r\n        const itemProps = useSelectItem(props, ref);\r\n\r\n        return (\r\n            <dreamy.button {...(itemProps as any)}>\r\n                {itemProps.children}\r\n\r\n                {(selectedStrategy === \"checkmark\" || selectedStrategy === \"both\") &&\r\n                    selectedKeys.includes(itemProps.value) && <SelectItemIndicator />}\r\n            </dreamy.button>\r\n        );\r\n    }),\r\n    \"item\"\r\n);\r\n\r\nconst SelectIndicator = withContext(CheckIcon, \"indicator\");\r\n\r\nexport interface SelectClearButtonProps extends HTMLDreamyProps<\"button\"> {}\r\n\r\nconst SelectClearButton = withContext(\r\n    forwardRef<HTMLButtonElement, SelectClearButtonProps>(function SelectClearButton(props, ref) {\r\n        const { getClearButtonProps } = useSelectContext();\r\n\r\n        return (\r\n            <dreamy.button {...getClearButtonProps(props, ref)}>\r\n                <dreamy.svg asChild>\r\n                    <svg\r\n                        aria-hidden=\"true\"\r\n                        fill=\"none\"\r\n                        stroke=\"currentColor\"\r\n                        strokeLinecap=\"round\"\r\n                        strokeLinejoin=\"round\"\r\n                        strokeWidth=\"2\"\r\n                        viewBox=\"0 0 24 24\"\r\n                        xmlns=\"http://www.w3.org/2000/svg\"\r\n                    >\r\n                        <path d=\"M18 6 6 18\" />\r\n                        <path d=\"m6 6 12 12\" />\r\n                    </svg>\r\n                </dreamy.svg>\r\n            </dreamy.button>\r\n        );\r\n    }),\r\n    \"clearButton\"\r\n);\r\n\r\nexport namespace Select {\r\n    export const Root = SelectRoot;\r\n    export const Trigger = SelectTrigger;\r\n    export const Content = SelectContent;\r\n    export const VirtualContent = SelectVirtualContent;\r\n    export const Item = SelectItem;\r\n}\r\n"
  },
  "component": "Select",
  "hasRecipe": true,
  "hasPattern": false,
  "recipeIds": [
    "select"
  ]
}