{
  "type": "component",
  "npmDependencies": [
    "@tanstack/react-virtual"
  ],
  "fileDependencies": [
    "./box",
    "./popover",
    "./visually-hidden"
  ],
  "id": "select",
  "file": {
    "name": "select.tsx",
    "content": "\"use client\";\n\nimport {\n    type FocusableElement,\n    SelectDescendantsProvider,\n    SelectProvider,\n    type UseSelectItemProps,\n    type UseSelectProps,\n    useHiddenSelect,\n    useSafeLayoutEffect,\n    useSelect,\n    useSelectContext,\n    useSelectItem\n} from \"@dreamy-ui/react\";\nimport { useVirtualizer } from \"@tanstack/react-virtual\";\nimport type React from \"react\";\nimport {\n    Children,\n    type ReactNode,\n    type RefObject,\n    type SVGProps,\n    forwardRef,\n    useRef,\n    useState\n} from \"react\";\nimport { type HTMLDreamyProps, createStyleContext, dreamy, splitCssProps } from \"styled-system/jsx\";\nimport { type SelectVariantProps, select } from \"styled-system/recipes\";\nimport { Box } from \"./box\";\nimport {\n    Content as PopoverContent,\n    type PopoverContentProps,\n    type PopoverProps,\n    Root as PopoverRoot,\n    Trigger as PopoverTrigger\n} from \"./popover\";\nimport { VisuallyHidden } from \"./visually-hidden\";\n\nconst { withProvider, withContext } = createStyleContext(select);\n\nexport interface HiddenSelectProps {\n    placeholder: string;\n    multiple: boolean;\n    autoComplete: string;\n    triggerRef: RefObject<FocusableElement | null>;\n    domRef: RefObject<HTMLSelectElement | null>;\n    onChange?: (e: React.ChangeEvent<HTMLSelectElement>) => void;\n    onChangeValue?: (value: string | string[]) => void;\n}\n\nfunction HiddenSelect(props: HiddenSelectProps) {\n    const { domRef, placeholder } = props;\n\n    const { containerProps, selectProps, descendants, id, selectedKeys } = useHiddenSelect({\n        ...props,\n        domRef\n    });\n\n    const [, forceUpdate] = useState({});\n\n    useSafeLayoutEffect(() => {\n        forceUpdate({});\n    }, []);\n\n    const items = Array.from(descendants.values());\n\n    return (\n        <VisuallyHidden {...containerProps}>\n            <label>\n                {placeholder}\n                <select\n                    {...selectProps}\n                    ref={domRef}\n                >\n                    <option />\n                    {items.map((item: any) => {\n                        const isSelected = selectProps.multiple\n                            ? selectedKeys.includes(item.node.value)\n                            : undefined;\n\n                        return (\n                            <option\n                                key={`${id}-${item.node.value}`}\n                                selected={isSelected}\n                                value={item.node.value}\n                            >\n                                {item.textValue}\n                            </option>\n                        );\n                    })}\n                </select>\n            </label>\n        </VisuallyHidden>\n    );\n}\n\nexport interface SelectProps<T extends boolean>\n    extends UseSelectProps<T, PopoverProps>,\n        SelectVariantProps,\n        Omit<HTMLDreamyProps<\"div\">, keyof UseSelectProps<T, PopoverProps>> {\n    children?: ReactNode;\n}\n\n/**\n * Select component\n *\n * @See Docs https://dreamy-ui.com/docs/components/select\n */\nexport const Root: <T extends boolean = false>(props: SelectProps<T>) => React.JSX.Element =\n    withProvider(function SelectRoot<T extends boolean = false>({\n        children,\n        ...props\n    }: SelectProps<T>) {\n        const [cssProps, restProps] = splitCssProps(props);\n        const ctx = useSelect<T, PopoverProps>(restProps);\n\n        return (\n            <SelectProvider value={ctx as any}>\n                <Box\n                    {...ctx.getRootProps({\n                        ...cssProps,\n                        className: restProps.className\n                    })}\n                >\n                    <HiddenSelect {...ctx.getHiddenSelectProps()} />\n                    <PopoverRoot\n                        hasArrow={false}\n                        initialFocusRef={ctx.triggerRef}\n                        isOpen={ctx.isOpen}\n                        lazyBehavior=\"keepMounted\"\n                        onClose={ctx.onClose}\n                        onOpen={ctx.onOpen}\n                        placement=\"bottom\"\n                        reduceMotion={ctx.reduceMotion}\n                        {...props.popoverProps}\n                    >\n                        <SelectDescendantsProvider value={ctx.descendants}>\n                            {children}\n                        </SelectDescendantsProvider>\n                    </PopoverRoot>\n                </Box>\n            </SelectProvider>\n        );\n    }, \"root\") as any;\n\nexport interface SelectTriggerProps extends HTMLDreamyProps<\"button\"> {\n    /**\n     * Icon to show in the trigger.\n     */\n    icon?: React.ReactNode;\n    /**\n     * Placeholder text to show when no item is selected.\n     */\n    placeholder?: string;\n    /**\n     * Text to show when multiple items are selected.\n     */\n    multipleSelectedText?: (selectedKeys: string[]) => string;\n}\n\nexport const Trigger = withContext(\n    forwardRef<HTMLButtonElement, SelectTriggerProps>(function SelectTrigger(\n        {\n            children,\n            placeholder,\n            icon,\n            multipleSelectedText = (selectedKeys) => `${selectedKeys.length} Selected`,\n            ...rest\n        },\n        ref\n    ) {\n        const { getTriggerProps, selectedKeys, descendants, isClearable } = useSelectContext();\n\n        const selectedNames = selectedKeys.map((key) => {\n            const item: any = Array.from(descendants.values()).find((node: any) => {\n                return node.node.value === key;\n            });\n            return item?.textValue;\n        });\n\n        const [, forceUpdate] = useState({});\n\n        useSafeLayoutEffect(() => {\n            forceUpdate({});\n        }, [JSON.stringify(Array.from(descendants.values()).map((node: any) => node.node.value))]);\n\n        return (\n            <>\n                <PopoverTrigger>\n                    <dreamy.button {...(getTriggerProps(rest, ref) as any)}>\n                        {icon && icon}\n\n                        <span>\n                            {selectedNames.length === 1\n                                ? selectedNames[0]\n                                : selectedNames.length > 1\n                                  ? multipleSelectedText(selectedNames)\n                                  : placeholder}\n                        </span>\n                        <SelectIndicatorGroup>\n                            {isClearable && selectedKeys.length > 0 && <SelectClearButton />}\n                            <SelectIndicator />\n                        </SelectIndicatorGroup>\n                    </dreamy.button>\n                </PopoverTrigger>\n            </>\n        );\n    }),\n    \"trigger\"\n);\n\nexport interface SelectContentProps extends PopoverContentProps {}\n\nexport const Content = withContext(\n    forwardRef<HTMLDivElement, SelectContentProps>(function SelectContent(props, ref) {\n        const { children, ...rest } = props;\n        const { getContentProps } = useSelectContext();\n        const contentPropsResult = getContentProps(rest, ref);\n\n        return <PopoverContent {...contentPropsResult}>{children}</PopoverContent>;\n    }),\n    \"content\"\n);\n\nexport interface SelectVirtualContentProps extends PopoverContentProps {\n    /**\n     * Estimated height of each item in pixels.\n     * Used for virtualization calculations.\n     * @default 32\n     */\n    estimatedItemHeight?: number;\n    /**\n     * Number of items to render outside the visible area.\n     * Higher values reduce flickering during fast scrolling but increase initial render cost.\n     * @default 5\n     */\n    overscan?: number;\n    /**\n     * Maximum height of the virtualized list container in pixels.\n     * @default 300\n     */\n    maxHeight?: number;\n}\n\n/**\n * Virtualized SelectContent for better performance with large lists.\n * Only renders visible items.\n */\nexport const VirtualContent = withContext(\n    forwardRef<HTMLDivElement, SelectVirtualContentProps>(\n        function SelectVirtualContent(props, ref) {\n            const {\n                children,\n                estimatedItemHeight = 32,\n                overscan = 5,\n                maxHeight = 300,\n                ...rest\n            } = props;\n\n            const { getContentProps, isOpen, selectedKeys } = useSelectContext();\n            const contentPropsResult = getContentProps(rest, ref);\n\n            return (\n                <PopoverContent {...contentPropsResult}>\n                    <VirtualizedList\n                        estimatedItemHeight={estimatedItemHeight}\n                        isOpen={isOpen}\n                        maxHeight={maxHeight}\n                        overscan={overscan}\n                        selectedKeys={selectedKeys}\n                    >\n                        {children}\n                    </VirtualizedList>\n                </PopoverContent>\n            );\n        }\n    ),\n    \"content\"\n);\n\ninterface VirtualizedListProps {\n    children: ReactNode;\n    estimatedItemHeight: number;\n    overscan: number;\n    maxHeight: number;\n    isOpen: boolean;\n    selectedKeys: string[];\n}\n\nfunction VirtualizedList({\n    children,\n    estimatedItemHeight,\n    overscan,\n    maxHeight,\n    isOpen,\n    selectedKeys\n}: VirtualizedListProps) {\n    const scrollContainerRef = useRef<HTMLDivElement>(null);\n    const childArray = Children.toArray(children);\n    const [hasMeasured, setHasMeasured] = useState(false);\n\n    const virtualizer = useVirtualizer({\n        count: childArray.length,\n        getScrollElement: () => scrollContainerRef.current,\n        estimateSize: () => estimatedItemHeight,\n        overscan\n    });\n\n    // Force remeasure when popover opens\n    useSafeLayoutEffect(() => {\n        if (isOpen && scrollContainerRef.current) {\n            // Use requestAnimationFrame to ensure the DOM has fully painted\n            requestAnimationFrame(() => {\n                virtualizer.measure();\n                setHasMeasured(true);\n            });\n        }\n    }, [isOpen, virtualizer]);\n\n    const virtualItems = virtualizer.getVirtualItems();\n    const totalSize = virtualizer.getTotalSize();\n\n    // Find indices of selected items to always render them\n    const selectedIndices = new Set<number>();\n    childArray.forEach((child, index) => {\n        if (\n            child &&\n            typeof child === \"object\" &&\n            \"props\" in child &&\n            selectedKeys.includes((child as React.ReactElement<{ value: string }>).props.value)\n        ) {\n            selectedIndices.add(index);\n        }\n    });\n\n    // Get the set of indices that are already being rendered by virtualizer\n    const virtualizedIndices = new Set(virtualItems.map((item) => item.index));\n\n    // Find selected items that are NOT in the virtualized view\n    const hiddenSelectedIndices = Array.from(selectedIndices).filter(\n        (index) => !virtualizedIndices.has(index)\n    );\n\n    // If we haven't measured yet but we're open, show initial items as fallback\n    const showFallback =\n        isOpen && !hasMeasured && virtualItems.length === 0 && childArray.length > 0;\n    const initialItemsToShow = Math.min(\n        Math.ceil(maxHeight / estimatedItemHeight) + overscan,\n        childArray.length\n    );\n\n    return (\n        <div\n            ref={scrollContainerRef}\n            style={{\n                maxHeight,\n                overflowY: \"auto\",\n                width: \"100%\"\n            }}\n        >\n            <div\n                style={{\n                    height: showFallback ? childArray.length * estimatedItemHeight : totalSize,\n                    width: \"100%\",\n                    position: \"relative\"\n                }}\n            >\n                {showFallback\n                    ? childArray.slice(0, initialItemsToShow).map((child, index) => (\n                          <div\n                              key={index}\n                              style={{\n                                  position: \"absolute\",\n                                  top: 0,\n                                  left: 0,\n                                  width: \"100%\",\n                                  transform: `translateY(${index * estimatedItemHeight}px)`\n                              }}\n                          >\n                              {child}\n                          </div>\n                      ))\n                    : virtualItems.map((virtualItem) => (\n                          <div\n                              data-index={virtualItem.index}\n                              key={virtualItem.key}\n                              ref={virtualizer.measureElement}\n                              style={{\n                                  position: \"absolute\",\n                                  top: 0,\n                                  left: 0,\n                                  width: \"100%\",\n                                  transform: `translateY(${virtualItem.start}px)`\n                              }}\n                          >\n                              {childArray[virtualItem.index]}\n                          </div>\n                      ))}\n\n                {/* Always render selected items that are outside the virtualized view (hidden but mounted for descendants registration) */}\n                {!showFallback &&\n                    hiddenSelectedIndices.map((index) => (\n                        <div\n                            aria-hidden=\"true\"\n                            key={`selected-${index}`}\n                            style={{\n                                position: \"absolute\",\n                                top: 0,\n                                left: 0,\n                                width: \"100%\",\n                                pointerEvents: \"none\",\n                                visibility: \"hidden\"\n                            }}\n                        >\n                            {childArray[index]}\n                        </div>\n                    ))}\n            </div>\n        </div>\n    );\n}\n\nexport interface SelectItemProps extends UseSelectItemProps {}\n\n/**\n * @internal\n */\nconst SelectIndicatorGroup = withContext(Box, \"indicatorGroup\");\n\nconst CheckIcon = forwardRef<SVGSVGElement, SVGProps<SVGSVGElement>>(\n    function CheckIcon(props, ref) {\n        return (\n            <svg\n                aria-hidden=\"true\"\n                fill=\"none\"\n                height=\"16\"\n                stroke=\"currentColor\"\n                strokeLinecap=\"round\"\n                strokeLinejoin=\"round\"\n                strokeWidth=\"2\"\n                viewBox=\"0 0 24 24\"\n                width=\"16\"\n                {...props}\n                ref={ref}\n            >\n                <path d=\"M20 6 9 17l-5-5\" />\n            </svg>\n        );\n    }\n);\n\nconst SelectItemIndicator = withContext(CheckIcon, \"itemIndicator\");\n\nexport const Item = withContext(\n    forwardRef<HTMLDivElement, SelectItemProps>(function SelectItem(props, ref) {\n        const { selectedStrategy, selectedKeys } = useSelectContext();\n        const itemProps = useSelectItem(props, ref);\n\n        return (\n            <dreamy.button {...(itemProps as any)}>\n                {itemProps.children}\n\n                {(selectedStrategy === \"checkmark\" || selectedStrategy === \"both\") &&\n                    selectedKeys.includes(itemProps.value) && <SelectItemIndicator />}\n            </dreamy.button>\n        );\n    }),\n    \"item\"\n);\n\nconst SelectIndicatorBase = forwardRef<SVGSVGElement, SVGProps<SVGSVGElement>>(\n    function SelectIndicator(props, ref) {\n        return (\n            <svg\n                aria-hidden=\"true\"\n                fill=\"none\"\n                stroke=\"currentColor\"\n                strokeLinecap=\"round\"\n                strokeLinejoin=\"round\"\n                strokeWidth=\"2\"\n                viewBox=\"0 0 24 24\"\n                xmlns=\"http://www.w3.org/2000/svg\"\n                {...props}\n                ref={ref}\n            >\n                <path d=\"m6 9 6 6 6-6\" />\n            </svg>\n        );\n    }\n);\n\nconst SelectIndicator = withContext(SelectIndicatorBase, \"indicator\");\n\nexport interface SelectClearButtonProps extends HTMLDreamyProps<\"button\"> {}\n\nconst SelectClearButton = withContext(\n    forwardRef<HTMLButtonElement, SelectClearButtonProps>(function SelectClearButton(props, ref) {\n        const { getClearButtonProps } = useSelectContext();\n\n        return (\n            <dreamy.button {...getClearButtonProps(props, ref)}>\n                <dreamy.svg asChild>\n                    <svg\n                        aria-hidden=\"true\"\n                        fill=\"none\"\n                        stroke=\"currentColor\"\n                        strokeLinecap=\"round\"\n                        strokeLinejoin=\"round\"\n                        strokeWidth=\"2\"\n                        viewBox=\"0 0 24 24\"\n                        xmlns=\"http://www.w3.org/2000/svg\"\n                    >\n                        <path d=\"M18 6 6 18\" />\n                        <path d=\"m6 6 12 12\" />\n                    </svg>\n                </dreamy.svg>\n            </dreamy.button>\n        );\n    }),\n    \"clearButton\"\n);\n"
  },
  "component": "Select",
  "hasRecipe": true,
  "hasPattern": false,
  "recipeIds": [
    "select"
  ]
}