{
  "type": "component",
  "fileDependencies": [
    "./motion"
  ],
  "id": "ripple",
  "file": {
    "name": "ripple.tsx",
    "content": "\"use client\";\n\nimport { clampValue, getId, useDisableRipple } from \"@dreamy-ui/react\";\nimport type { HTMLMotionProps } from \"motion/react\";\nimport { AnimatePresence } from \"motion/react\";\nimport type React from \"react\";\nimport { useCallback, useState } from \"react\";\nimport { MotionBox } from \"./motion\";\n\nexport interface RippleProps {\n    ripples: RippleType[];\n    currentRipple: string | null;\n    color?: string;\n    motionProps?: HTMLMotionProps<\"div\">;\n    style?: React.CSSProperties;\n    onClear: (key: React.Key) => void;\n}\n\n/**\n * Ripple component. Use with `useRipple` hook.\n */\nexport function Ripple(props: RippleProps) {\n    const {\n        ripples = [],\n        currentRipple,\n        motionProps,\n        color = \"currentColor\",\n        style,\n        onClear\n    } = props;\n\n    return ripples.map((ripple) => {\n        const isEdgingThisRipple = !!currentRipple && ripples.at(-1)?.key === ripple.key;\n        const duration = clampValue(\n            0.01 * ripple.size,\n            isEdgingThisRipple ? 2 : 0.3,\n            isEdgingThisRipple ? 3 : ripple.size > 100 ? 0.75 : 0.4\n        );\n\n        return (\n            <AnimatePresence\n                mode=\"popLayout\"\n                key={ripple.key}\n            >\n                <MotionBox\n                    initial={{\n                        scale: 0,\n                        opacity: 0.4\n                    }}\n                    animate={{\n                        scale: isEdgingThisRipple ? 1.8 : 2,\n                        opacity: isEdgingThisRipple ? 0 : 0.01\n                    }}\n                    exit={{ opacity: 0 }}\n                    style={{\n                        position: \"absolute\",\n                        backgroundColor: color,\n                        borderRadius: \"100%\",\n                        transformOrigin: \"center\",\n                        pointerEvents: \"none\",\n                        overflow: \"hidden\",\n                        inset: 0,\n                        zIndex: 0,\n                        top: ripple.y,\n                        left: ripple.x,\n                        width: `${ripple.size}px`,\n                        height: `${ripple.size}px`,\n                        willChange: \"transform, opacity\",\n                        ...style\n                    }}\n                    transition={{ duration }}\n                    onAnimationComplete={() => {\n                        setTimeout(() => {\n                            onClear(ripple.key);\n                        }, duration * 1000);\n                    }}\n                    {...motionProps}\n                    data-part=\"ripple\"\n                />\n            </AnimatePresence>\n        );\n    });\n}\n\nexport type RippleType = {\n    key: React.Key;\n    x: number;\n    y: number;\n    size: number;\n};\n\nexport type UseRippleProps = {};\n\nexport function useRipple(props: UseRippleProps = {}) {\n    const isGloballyDisabled = useDisableRipple();\n    const [ripples, setRipples] = useState<RippleType[]>([]);\n\n    const [currentRipple, setCurrentRipple] = useState<string | null>(null);\n\n    const onPointerDown = useCallback(\n        (event: React.PointerEvent<HTMLElement> | React.MouseEvent<HTMLElement, MouseEvent>) => {\n            const trigger = event.currentTarget;\n            /**\n             * Allow only main mouse button clicks.\n             * Allowing also secondary, since some people use left-handed mouse.\n             */\n            if (event.button !== 0 && event.button !== 2) return;\n\n            const size = Math.max(trigger.clientWidth, trigger.clientHeight);\n            const rect = trigger.getBoundingClientRect();\n\n            const key = getId();\n\n            setRipples((prevRipples) => [\n                ...prevRipples.slice(-3),\n                {\n                    key,\n                    size,\n                    x: event.clientX - rect.left - size / 2,\n                    y: event.clientY - rect.top - size / 2\n                }\n            ]);\n            setCurrentRipple(key);\n        },\n        []\n    );\n\n    const onClick = useCallback((_event: React.MouseEvent<HTMLElement, MouseEvent>) => {\n        setCurrentRipple(null);\n    }, []);\n\n    const onClear = useCallback((key: React.Key) => {\n        setRipples((prevState) => prevState.filter((ripple) => ripple.key !== key));\n    }, []);\n\n    return {\n        ripples,\n        onClick,\n        onPointerDown,\n        onClear,\n        currentRipple,\n        isDisabled: isGloballyDisabled,\n        ...props\n    };\n}\n\nexport type UseRippleReturn = ReturnType<typeof useRipple>;\n"
  },
  "component": "Ripple",
  "hasRecipe": false,
  "hasPattern": false
}