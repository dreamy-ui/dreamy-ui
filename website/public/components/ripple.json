{
  "type": "component",
  "fileDependencies": [
    "./motion"
  ],
  "id": "ripple",
  "file": {
    "name": "ripple.tsx",
    "content": "\"use client\";\r\n\r\nimport { clampValue, getId, useDisableRipple } from \"@dreamy-ui/react\";\r\nimport type { HTMLMotionProps } from \"motion/react\";\r\nimport { AnimatePresence } from \"motion/react\";\r\nimport type React from \"react\";\r\nimport { useCallback, useState } from \"react\";\r\nimport { MotionBox } from \"./motion\";\r\n\r\nexport interface RippleProps {\r\n    ripples: IRipple[];\r\n    currentRipple: string | null;\r\n    color?: string;\r\n    motionProps?: HTMLMotionProps<\"div\">;\r\n    style?: React.CSSProperties;\r\n    onClear: (key: React.Key) => void;\r\n}\r\n\r\n/**\r\n * Ripple component. Use with `useRipple` hook.\r\n */\r\nexport function Ripple(props: RippleProps) {\r\n    const {\r\n        ripples = [],\r\n        currentRipple,\r\n        motionProps,\r\n        color = \"currentColor\",\r\n        style,\r\n        onClear\r\n    } = props;\r\n\r\n    return ripples.map((ripple) => {\r\n        const isEdgingThisRipple = !!currentRipple && ripples.at(-1)?.key === ripple.key;\r\n        const duration = clampValue(\r\n            0.01 * ripple.size,\r\n            isEdgingThisRipple ? 2 : 0.3,\r\n            isEdgingThisRipple ? 3 : ripple.size > 100 ? 0.75 : 0.4\r\n        );\r\n\r\n        return (\r\n            <AnimatePresence\r\n                mode=\"popLayout\"\r\n                key={ripple.key}\r\n            >\r\n                <MotionBox\r\n                    initial={{\r\n                        scale: 0,\r\n                        opacity: 0.4\r\n                    }}\r\n                    animate={{\r\n                        scale: isEdgingThisRipple ? 1.8 : 2,\r\n                        opacity: isEdgingThisRipple ? 0 : 0.01\r\n                    }}\r\n                    exit={{ opacity: 0 }}\r\n                    style={{\r\n                        position: \"absolute\",\r\n                        backgroundColor: color,\r\n                        borderRadius: \"100%\",\r\n                        transformOrigin: \"center\",\r\n                        pointerEvents: \"none\",\r\n                        overflow: \"hidden\",\r\n                        inset: 0,\r\n                        zIndex: 0,\r\n                        top: ripple.y,\r\n                        left: ripple.x,\r\n                        width: `${ripple.size}px`,\r\n                        height: `${ripple.size}px`,\r\n                        willChange: \"transform, opacity\",\r\n                        ...style\r\n                    }}\r\n                    transition={{\r\n                        type: \"spring\",\r\n                        stiffness: isEdgingThisRipple ? 20 : 80,\r\n                        damping: isEdgingThisRipple ? 25 : 20\r\n                    }}\r\n                    onAnimationComplete={() => {\r\n                        setTimeout(() => {\r\n                            onClear(ripple.key);\r\n                        }, duration * 1000);\r\n                    }}\r\n                    {...motionProps}\r\n                    data-part=\"ripple\"\r\n                />\r\n            </AnimatePresence>\r\n        );\r\n    });\r\n}\r\n\r\nexport interface IRipple {\r\n    key: React.Key;\r\n    x: number;\r\n    y: number;\r\n    size: number;\r\n}\r\n\r\nexport type UseRippleProps = {};\r\n\r\nexport function useRipple(props: UseRippleProps = {}) {\r\n    const isGloballyDisabled = useDisableRipple();\r\n    const [ripples, setRipples] = useState<IRipple[]>([]);\r\n\r\n    const [currentRipple, setCurrentRipple] = useState<string | null>(null);\r\n\r\n    const onPointerDown = useCallback(\r\n        (event: React.PointerEvent<HTMLElement> | React.MouseEvent<HTMLElement, MouseEvent>) => {\r\n            const trigger = event.currentTarget;\r\n            /**\r\n             * Allow only main mouse button clicks.\r\n             * Allowing also secondary, since some people use left-handed mouse.\r\n             */\r\n            if (event.button !== 0 && event.button !== 2) return;\r\n\r\n            const size = Math.max(trigger.clientWidth, trigger.clientHeight);\r\n            const rect = trigger.getBoundingClientRect();\r\n\r\n            const key = getId();\r\n\r\n            setRipples((prevRipples) => [\r\n                ...prevRipples.slice(-3),\r\n                {\r\n                    key,\r\n                    size,\r\n                    x: event.clientX - rect.left - size / 2,\r\n                    y: event.clientY - rect.top - size / 2\r\n                }\r\n            ]);\r\n            setCurrentRipple(key);\r\n        },\r\n        []\r\n    );\r\n\r\n    const onClick = useCallback((_event: React.MouseEvent<HTMLElement, MouseEvent>) => {\r\n        setCurrentRipple(null);\r\n    }, []);\r\n\r\n    const onClear = useCallback((key: React.Key) => {\r\n        setRipples((prevState) => prevState.filter((ripple) => ripple.key !== key));\r\n    }, []);\r\n\r\n    return {\r\n        ripples,\r\n        onClick,\r\n        onPointerDown,\r\n        onClear,\r\n        currentRipple,\r\n        isDisabled: isGloballyDisabled,\r\n        ...props\r\n    };\r\n}\r\n\r\nexport type UseRippleReturn = ReturnType<typeof useRipple>;\r\n"
  },
  "component": "Ripple",
  "hasRecipe": false,
  "hasPattern": false
}