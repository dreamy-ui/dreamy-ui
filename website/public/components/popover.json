{
  "type": "component",
  "fileDependencies": [
    "./box",
    "./close-button",
    "./factory",
    "./heading",
    "./motion",
    "./style-context"
  ],
  "id": "popover",
  "file": {
    "name": "popover.tsx",
    "content": "import {\n    type MaybeRenderProp,\n    PopoverProvider,\n    type UsePopoverProps,\n    callAll,\n    callAllHandlers,\n    runIfFn,\n    transformReducedMotion,\n    useMotionVariants,\n    usePopover,\n    usePopoverContext\n} from \"@dreamy-ui/react\";\nimport type { HTMLMotionProps } from \"motion/react\";\nimport { Children, cloneElement, forwardRef } from \"react\";\nimport { popover } from \"styled-system/recipes\";\nimport { Box, type BoxProps } from \"./box\";\nimport { CloseButton, type CloseButtonProps } from \"./close-button\";\nimport type { HTMLDreamyProps } from \"./factory\";\nimport { Heading } from \"./heading\";\nimport { MotionBox } from \"./motion\";\nimport { createStyleContext } from \"./style-context\";\n\nconst { withProvider, withContext } = createStyleContext(popover);\n\nexport interface PopoverProps extends UsePopoverProps {\n    /**\n     * The content of the popover. It is usually the `PopoverTrigger`,\n     * and `PopoverContent`\n     */\n    children?: MaybeRenderProp<{\n        isOpen: boolean;\n        onClose: () => void;\n        forceUpdate: (() => void) | undefined;\n    }>;\n    /**\n     * If `true`, the popover will have an arrow pointing to the trigger\n     * @default true\n     */\n    hasArrow?: boolean;\n}\n\n/**\n * Popover component\n *\n * @See Docs https://dreamy-ui.com/docs/components/popover\n */\nexport const Popover = withProvider(function PopoverRoot(props: PopoverProps) {\n    const { children, direction, hasArrow, ...rest } = props;\n\n    const context = usePopover({ ...rest, direction: direction ?? \"ltr\" });\n\n    return (\n        <PopoverProvider\n            value={{\n                ...context,\n                hasArrow: hasArrow ?? false\n            }}\n        >\n            {runIfFn(children, {\n                isOpen: context.isOpen,\n                onClose: context.onClose,\n                forceUpdate: context.forceUpdate\n            })}\n        </PopoverProvider>\n    );\n});\n\nexport interface PopoverArrowProps extends HTMLDreamyProps<\"div\"> {}\n\nexport function PopoverArrow(props: PopoverArrowProps) {\n    return (\n        <Box\n            data-popper-arrow\n            style={{\n                backgroundColor: \"transparent\"\n            }}\n        >\n            <Box\n                data-popper-arrow-inner\n                {...props}\n            />\n        </Box>\n    );\n}\n\ntype HTMLMotionDreamProps<T extends keyof HTMLElementTagNameMap> = Omit<\n    HTMLDreamyProps<T>,\n    keyof HTMLMotionProps<T>\n> & {\n    children?: React.ReactNode;\n} & Omit<\n        HTMLMotionProps<T>,\n        | \"style\"\n        | \"onDrag\"\n        | \"onDragEnd\"\n        | \"onDragStart\"\n        | \"onAnimationStart\"\n        | \"variants\"\n        | \"transition\"\n        | \"children\"\n    >;\n\nexport interface PopoverTransitionProps extends HTMLMotionDreamProps<\"section\"> {\n    /**\n     * Props to be forwarded to the arrow component\n     */\n    arrowProps?: PopoverArrowProps;\n}\n\nconst PopoverTransition = forwardRef(function PopoverTransition(\n    props: PopoverTransitionProps,\n    ref: React.Ref<any>\n) {\n    const { children, arrowProps, ...rest } = props;\n\n    const { isOpen, hasArrow, reduceMotion } = usePopoverContext();\n    const { popover } = useMotionVariants();\n\n    return (\n        <MotionBox\n            ref={ref as any}\n            variants={transformReducedMotion(popover.default, reduceMotion)}\n            initial={false}\n            animate={isOpen ? \"initial\" : \"exit\"}\n            {...rest}\n        >\n            {hasArrow && <PopoverArrow {...arrowProps} />}\n            {children}\n        </MotionBox>\n    );\n});\n\nexport interface PopoverContentProps extends PopoverTransitionProps {\n    rootProps?: HTMLDreamyProps<\"div\">;\n    motionProps?: Omit<HTMLMotionProps<\"section\">, \"children\">;\n}\n\nexport const PopoverContent = withContext(\n    forwardRef<HTMLElement, PopoverContentProps>(function PopoverContent(props, ref) {\n        const { rootProps, motionProps, ...contentProps } = props;\n\n        const { getPopoverProps, getPopoverPositionerProps, onAnimationComplete } =\n            usePopoverContext();\n\n        if (typeof document === \"undefined\") return null;\n\n        return (\n            <div {...getPopoverPositionerProps(rootProps)}>\n                <PopoverTransition\n                    {...(motionProps as any)}\n                    {...getPopoverProps(contentProps, ref)}\n                    onAnimationComplete={callAll(\n                        onAnimationComplete,\n                        contentProps.onAnimationComplete\n                    )}\n                />\n            </div>\n        );\n    }),\n    \"content\"\n);\n\nexport interface PopoverHeaderProps extends HTMLDreamyProps<\"header\"> {}\n\nexport const PopoverHeader = withContext(\n    forwardRef<HTMLDivElement, PopoverHeaderProps>(function PopoverHeader(props, ref) {\n        const { children, ...rest } = props;\n        const { getHeaderProps } = usePopoverContext();\n\n        return (\n            <Box\n                as={\"header\"}\n                {...getHeaderProps(rest, ref)}\n            >\n                {typeof children === \"string\" ? (\n                    <Heading\n                        variant={\"heading\"}\n                        size=\"md\"\n                    >\n                        {children}\n                    </Heading>\n                ) : (\n                    children\n                )}\n            </Box>\n        );\n    }),\n    \"header\"\n);\n\nexport interface PopoverBodyProps extends HTMLDreamyProps<\"div\"> {}\n\nexport const PopoverBody = withContext(\n    forwardRef<HTMLDivElement, PopoverBodyProps>(function PopoverHeader(props, ref) {\n        const { getBodyProps } = usePopoverContext();\n\n        return <Box {...getBodyProps(props, ref)} />;\n    }),\n    \"body\"\n);\n\nexport interface PopoverFooterProps extends BoxProps {}\n\nexport const PopoverFooter = withContext(\n    forwardRef<HTMLDivElement, PopoverFooterProps>(function PopoverFooter(props, ref) {\n        return (\n            <Box\n                as={\"footer\"}\n                {...props}\n                ref={ref}\n            />\n        );\n    }),\n    \"footer\"\n);\n\nexport interface PopoverCloseButtonProps extends CloseButtonProps {}\n\nexport const PopoverCloseButton = withContext(\n    forwardRef<HTMLButtonElement, PopoverCloseButtonProps>(function PopoverCloseButton(props, ref) {\n        const { onClose } = usePopoverContext();\n\n        return (\n            <CloseButton\n                {...props}\n                size={\"sm\"}\n                onClick={callAllHandlers(props.onClick, onClose)}\n                ref={ref}\n            />\n        );\n    }),\n    \"close\"\n);\n\n/**\n * PopoverAnchor is element that is used as the positioning reference\n * for the popover.\n */\nexport function PopoverAnchor(props: React.PropsWithChildren<{}>) {\n    const child: any = Children.only(props.children);\n    const { getAnchorProps } = usePopoverContext();\n\n    return <>{cloneElement(child, getAnchorProps(child.props, child.ref))}</>;\n}\n\n/**\n * PopoverTrigger opens the popover's content. It must be an interactive element\n * such as `button` or `a`.\n */\nexport function PopoverTrigger(props: { children: React.ReactNode }) {\n    const child: any = Children.only(props.children);\n    const { getTriggerProps } = usePopoverContext();\n\n    return <>{cloneElement(child, getTriggerProps(child.props, child.ref))}</>;\n}\n"
  },
  "component": "Popover",
  "hasRecipe": true,
  "hasPattern": false,
  "recipeIds": [
    "popover"
  ]
}