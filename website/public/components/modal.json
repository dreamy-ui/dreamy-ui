{
  "type": "component",
  "fileDependencies": [
    "./box",
    "./close-button",
    "./flex",
    "./heading",
    "./motion",
    "./style-context"
  ],
  "id": "modal",
  "file": {
    "name": "modal.tsx",
    "content": "\"use client\";\r\n\r\nimport {\r\n    FocusLock,\r\n    ModalContextProvider,\r\n    Portal,\r\n    type PortalProps,\r\n    RemoveScroll,\r\n    type UseModalProps,\r\n    useDefaultTransition,\r\n    useModal,\r\n    useModalContext,\r\n    useMotionVariants\r\n} from \"@dreamy-ui/react\";\r\nimport { AnimatePresence, usePresence } from \"motion/react\";\r\nimport { type RefObject, forwardRef, useEffect, useMemo, useState } from \"react\";\r\nimport { modal } from \"styled-system/recipes\";\r\nimport { Box, type BoxProps } from \"./box\";\r\nimport { CloseButton, type CloseButtonProps } from \"./close-button\";\r\nimport { Flex, type FlexProps } from \"./flex\";\r\nimport { Heading } from \"./heading\";\r\nimport { MotionBox, type MotionBoxProps, MotionFlex, type MotionFlexProps } from \"./motion\";\r\nimport { createStyleContext } from \"./style-context\";\r\n\r\nconst { withProvider, withContext } = createStyleContext(modal);\r\n\r\nexport interface ModalProps extends UseModalProps, ModalOptions {\r\n    children: React.ReactNode;\r\n    /**\r\n     * Where scroll behavior should originate.\r\n     * - If set to `inside`, scroll only occurs within the `ModalBody`.\r\n     * - If set to `outside`, the entire `ModalContent` will scroll within the viewport.\r\n     *\r\n     * @default \"outside\"\r\n     */\r\n    scrollBehavior?: ScrollBehavior;\r\n    /**\r\n     * Fires when all exiting nodes have completed animating out\r\n     */\r\n    onCloseComplete?: () => void;\r\n    /**\r\n     * Props to be forwarded to the portal component\r\n     */\r\n    portalProps?: PortalProps;\r\n}\r\n\r\n/**\r\n * Modal component\r\n *\r\n * @See Docs https://dreamy-ui.com/docs/components/modal\r\n */\r\nexport const Modal = withProvider(function ModalRoot(props: ModalProps) {\r\n    const modalProps: ModalProps = {\r\n        scrollBehavior: \"inside\",\r\n        autoFocus: true,\r\n        trapFocus: true,\r\n        returnFocusOnClose: true,\r\n        blockScrollOnMount: true,\r\n        allowPinchZoom: false,\r\n        preserveScrollBarGap: true,\r\n        ...props\r\n    };\r\n\r\n    const {\r\n        children,\r\n        autoFocus,\r\n        trapFocus,\r\n        initialFocusRef,\r\n        finalFocusRef,\r\n        returnFocusOnClose,\r\n        blockScrollOnMount,\r\n        scrollBehavior,\r\n        allowPinchZoom,\r\n        preserveScrollBarGap,\r\n        onCloseComplete,\r\n        portalProps\r\n    } = modalProps;\r\n\r\n    const modal = useModal(modalProps);\r\n\r\n    // biome-ignore lint/correctness/useExhaustiveDependencies: <explanation>\r\n    const context = useMemo(() => {\r\n        return {\r\n            ...modal,\r\n            autoFocus,\r\n            trapFocus,\r\n            initialFocusRef,\r\n            finalFocusRef,\r\n            returnFocusOnClose,\r\n            blockScrollOnMount,\r\n            allowPinchZoom,\r\n            preserveScrollBarGap,\r\n            onCloseComplete,\r\n            scrollBehavior\r\n        };\r\n    }, [modal]);\r\n\r\n    return (\r\n        <ModalContextProvider value={context}>\r\n            <AnimatePresence onExitComplete={onCloseComplete}>\r\n                {context.isOpen && (\r\n                    <Portal\r\n                        key={context.id}\r\n                        {...portalProps}\r\n                    >\r\n                        {children}\r\n                    </Portal>\r\n                )}\r\n            </AnimatePresence>\r\n        </ModalContextProvider>\r\n    );\r\n});\r\n\r\nexport interface ModalOverlayProps extends MotionBoxProps {}\r\n\r\nexport const ModalOverlay = withContext(\r\n    forwardRef<HTMLDivElement, ModalOverlayProps>((props, ref) => {\r\n        const { isOpen } = useModalContext();\r\n        const { overlay } = useMotionVariants();\r\n\r\n        return (\r\n            <AnimatePresence>\r\n                {isOpen && (\r\n                    <MotionBox\r\n                        variants={overlay.default}\r\n                        initial=\"initial\"\r\n                        animate=\"animate\"\r\n                        exit=\"exit\"\r\n                        ref={ref}\r\n                        {...props}\r\n                    />\r\n                )}\r\n            </AnimatePresence>\r\n        );\r\n    }),\r\n    \"overlay\"\r\n);\r\n\r\nexport interface ModalContainerProps extends MotionFlexProps {}\r\n\r\nexport const ModalContainer = withContext(\r\n    forwardRef<HTMLDivElement, BoxProps>(({ children, ...props }, ref) => {\r\n        const { getDialogContainerProps } = useModalContext();\r\n\r\n        return <Box {...getDialogContainerProps(props, ref)}>{children}</Box>;\r\n    }),\r\n    \"container\"\r\n);\r\n\r\nexport interface ModalContentProps extends MotionFlexProps {}\r\n\r\nexport const ModalContent = withContext(\r\n    forwardRef<HTMLDivElement, MotionFlexProps>(({ children, ...props }, ref) => {\r\n        const { getDialogProps } = useModalContext();\r\n        const { modal } = useMotionVariants();\r\n        const transition = useDefaultTransition();\r\n\r\n        return (\r\n            <>\r\n                <ModalFocusScope>\r\n                    <ModalContainer>\r\n                        <MotionFlex\r\n                            variants={modal.default}\r\n                            initial=\"initial\"\r\n                            animate=\"animate\"\r\n                            exit=\"exit\"\r\n                            transition={transition}\r\n                            {...(getDialogProps(props as any, ref) as any)}\r\n                        >\r\n                            {children}\r\n                        </MotionFlex>\r\n                    </ModalContainer>\r\n                </ModalFocusScope>\r\n            </>\r\n        );\r\n    }),\r\n    \"content\"\r\n);\r\n\r\nexport interface ModalHeaderProps extends FlexProps {}\r\n\r\nexport const ModalHeader = withContext(\r\n    forwardRef<HTMLDivElement, ModalHeaderProps>(({ children, ...props }, ref) => {\r\n        return (\r\n            <Flex\r\n                as={\"header\"}\r\n                {...props}\r\n                ref={ref}\r\n            >\r\n                {typeof children === \"string\" ? (\r\n                    <Heading\r\n                        variant={\"heading\"}\r\n                        size=\"lg\"\r\n                    >\r\n                        {children}\r\n                    </Heading>\r\n                ) : (\r\n                    children\r\n                )}\r\n            </Flex>\r\n        );\r\n    }),\r\n    \"header\"\r\n);\r\n\r\nexport interface ModalBodyProps extends FlexProps {}\r\n\r\nexport const ModalBody = withContext(\r\n    forwardRef<HTMLDivElement, ModalBodyProps>(({ children, style, ...props }, ref) => {\r\n        const { scrollBehavior } = useModalContext();\r\n\r\n        return (\r\n            <Flex\r\n                ref={ref}\r\n                {...props}\r\n                style={{\r\n                    maxHeight: scrollBehavior === \"inside\" ? \"calc(100vh - 10rem)\" : undefined,\r\n                    overflow: scrollBehavior === \"inside\" ? \"auto\" : undefined,\r\n                    ...style\r\n                }}\r\n            >\r\n                {children}\r\n            </Flex>\r\n        );\r\n    }),\r\n    \"body\"\r\n);\r\n\r\nexport interface ModalFooterProps extends FlexProps {}\r\n\r\nexport const ModalFooter = withContext(\r\n    forwardRef<HTMLDivElement, ModalFooterProps>(({ children, ...props }, ref) => {\r\n        return (\r\n            <Flex\r\n                as={\"footer\"}\r\n                {...props}\r\n                ref={ref}\r\n            >\r\n                {children}\r\n            </Flex>\r\n        );\r\n    }),\r\n    \"footer\"\r\n);\r\n\r\nexport interface ModalCloseButtonProps extends CloseButtonProps {}\r\n\r\nexport const ModalCloseButton = withContext(\r\n    forwardRef<HTMLButtonElement, ModalCloseButtonProps>(({ ...props }, ref) => {\r\n        const { onClose } = useModalContext();\r\n\r\n        return (\r\n            <CloseButton\r\n                ref={ref}\r\n                onClick={onClose}\r\n                {...props}\r\n            />\r\n        );\r\n    }),\r\n    \"close\"\r\n);\r\n\r\ninterface ModalFocusScopeProps {\r\n    children: React.ReactElement;\r\n}\r\n\r\nclass ModalManager {\r\n    modals: Map<HTMLElement, number>;\r\n    constructor() {\r\n        this.modals = new Map();\r\n    }\r\n\r\n    add(modal: HTMLElement) {\r\n        this.modals.set(modal, this.modals.size + 1);\r\n        return this.modals.size;\r\n    }\r\n\r\n    remove(modal: HTMLElement) {\r\n        this.modals.delete(modal);\r\n    }\r\n\r\n    isTopModal(modal: HTMLElement | null) {\r\n        if (!modal) return false;\r\n        return this.modals.get(modal) === this.modals.size;\r\n    }\r\n}\r\n\r\nexport const modalManager = new ModalManager();\r\n\r\nexport function useModalManager(ref: RefObject<HTMLElement | null>, isOpen?: boolean) {\r\n    const [index, setIndex] = useState(0);\r\n\r\n    useEffect(() => {\r\n        const node = ref.current;\r\n\r\n        if (!node) return;\r\n\r\n        if (isOpen) {\r\n            const index = modalManager.add(node);\r\n            setIndex(index);\r\n        }\r\n\r\n        return () => {\r\n            modalManager.remove(node);\r\n            setIndex(0);\r\n        };\r\n    }, [isOpen, ref]);\r\n\r\n    return index;\r\n}\r\n\r\nfunction ModalFocusScope(props: ModalFocusScopeProps) {\r\n    const {\r\n        autoFocus,\r\n        trapFocus,\r\n        dialogRef,\r\n        initialFocusRef,\r\n        blockScrollOnMount,\r\n        allowPinchZoom,\r\n        finalFocusRef,\r\n        returnFocusOnClose,\r\n        preserveScrollBarGap,\r\n        lockFocusAcrossFrames,\r\n        useInert,\r\n        isOpen\r\n    } = useModalContext();\r\n\r\n    const [isPresent, safeToRemove] = usePresence();\r\n\r\n    useEffect(() => {\r\n        if (!isPresent && safeToRemove) {\r\n            setTimeout(safeToRemove);\r\n        }\r\n    }, [isPresent, safeToRemove]);\r\n\r\n    const index = useModalManager(dialogRef, isOpen);\r\n\r\n    return (\r\n        <FocusLock\r\n            autoFocus={autoFocus}\r\n            isDisabled={!trapFocus}\r\n            initialFocusRef={initialFocusRef}\r\n            finalFocusRef={finalFocusRef}\r\n            restoreFocus={returnFocusOnClose}\r\n            contentRef={dialogRef}\r\n            lockFocusAcrossFrames={lockFocusAcrossFrames}\r\n        >\r\n            <RemoveScroll\r\n                removeScrollBar={!preserveScrollBarGap}\r\n                allowPinchZoom={allowPinchZoom}\r\n                // only block scroll for first dialog\r\n                enabled={index === 1 && blockScrollOnMount}\r\n                forwardProps\r\n                inert={useInert}\r\n            >\r\n                {props.children}\r\n            </RemoveScroll>\r\n        </FocusLock>\r\n    );\r\n}\r\n\r\ninterface ModalOptions {\r\n    /**\r\n     * If `false`, focus lock will be disabled completely.\r\n     *\r\n     * This is useful in situations where you still need to interact with\r\n     * other surrounding elements.\r\n     *\r\n     * ðŸš¨Warning: We don't recommend doing this because it hurts the\r\n     * accessibility of the modal, based on WAI-ARIA specifications.\r\n     *\r\n     * @default true\r\n     */\r\n    trapFocus?: boolean;\r\n    /**\r\n     * If `true`, the modal will autofocus the first enabled and interactive\r\n     * element within the `ModalContent`\r\n     *\r\n     * @default true\r\n     */\r\n    autoFocus?: boolean;\r\n    /**\r\n     * The `ref` of element to receive focus when the modal opens.\r\n     */\r\n    initialFocusRef?: React.RefObject<FocusableElement | null>;\r\n    /**\r\n     * The `ref` of element to receive focus when the modal closes.\r\n     */\r\n    finalFocusRef?: React.RefObject<FocusableElement | null>;\r\n    /**\r\n     * If `true`, the modal will return focus to the element that triggered it when it closes.\r\n     * @default true\r\n     */\r\n    returnFocusOnClose?: boolean;\r\n    /**\r\n     * If `true`, scrolling will be disabled on the `body` when the modal opens.\r\n     * @default true\r\n     */\r\n    blockScrollOnMount?: boolean;\r\n    /**\r\n     * Handle zoom/pinch gestures on iOS devices when scroll locking is enabled.\r\n     * @default false.\r\n     */\r\n    allowPinchZoom?: boolean;\r\n    /**\r\n     * If `true`, a `padding-right` will be applied to the body element\r\n     * that's equal to the width of the scrollbar.\r\n     *\r\n     * This can help prevent some unpleasant flickering effect\r\n     * and content adjustment when the modal opens\r\n     *\r\n     * @default true\r\n     */\r\n    preserveScrollBarGap?: boolean;\r\n\r\n    lockFocusAcrossFrames?: boolean;\r\n}\r\n\r\ntype ScrollBehavior = \"inside\" | \"outside\";\r\n\r\nexport interface FocusLockProps {\r\n    /**\r\n     * `ref` of the element to receive focus initially\r\n     */\r\n    initialFocusRef?: React.RefObject<FocusableElement | null>;\r\n    /**\r\n     * `ref` of the element to return focus to when `FocusLock`\r\n     * unmounts\r\n     */\r\n    finalFocusRef?: React.RefObject<FocusableElement | null>;\r\n    /**\r\n     * The `ref` of the wrapper for which the focus-lock wraps\r\n     */\r\n    contentRef?: React.RefObject<HTMLElement>;\r\n    /**\r\n     * If `true`, focus will be restored to the element that\r\n     * triggered the `FocusLock` once it unmounts\r\n     *\r\n     * @default false\r\n     */\r\n    restoreFocus?: boolean;\r\n    /**\r\n     * If `true`, focus trapping will be disabled\r\n     *\r\n     * @default false\r\n     */\r\n    disabled?: boolean;\r\n    /**\r\n     * If `true`, the first focusable element within the `children`\r\n     * will auto-focused once `FocusLock` mounts\r\n     *\r\n     * @default false\r\n     */\r\n    autoFocus?: boolean;\r\n    /**\r\n     * If `true`, disables text selections inside, and outside focus lock\r\n     *\r\n     * @default false\r\n     */\r\n    persistentFocus?: boolean;\r\n}\r\n\r\ninterface FocusableElement {\r\n    focus(options?: FocusOptions): void;\r\n}\r\n"
  },
  "component": "Modal",
  "hasRecipe": true,
  "hasPattern": false,
  "recipeIds": [
    "modal"
  ]
}