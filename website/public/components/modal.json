{
  "type": "component",
  "fileDependencies": [
    "./box",
    "./close-button",
    "./flex",
    "./heading",
    "./motion",
    "./style-context"
  ],
  "id": "modal",
  "file": {
    "name": "modal.tsx",
    "content": "\"use client\";\n\nimport {\n    FocusLock,\n    ModalContextProvider,\n    Portal,\n    type PortalProps,\n    RemoveScroll,\n    type UseModalProps,\n    useDefaultTransition,\n    useModal,\n    useModalContext,\n    useMotionVariants\n} from \"@dreamy-ui/react\";\nimport { AnimatePresence, usePresence } from \"motion/react\";\nimport { type RefObject, forwardRef, useEffect, useMemo, useState } from \"react\";\nimport { modal } from \"styled-system/recipes\";\nimport { Box, type BoxProps } from \"./box\";\nimport { CloseButton, type CloseButtonProps } from \"./close-button\";\nimport { Flex, type FlexProps } from \"./flex\";\nimport { Heading } from \"./heading\";\nimport { MotionBox, type MotionBoxProps, MotionFlex, type MotionFlexProps } from \"./motion\";\nimport { createStyleContext } from \"./style-context\";\n\nconst { withProvider, withContext } = createStyleContext(modal);\n\nexport interface ModalProps extends UseModalProps, ModalOptions {\n    children: React.ReactNode;\n    /**\n     * Where scroll behavior should originate.\n     * - If set to `inside`, scroll only occurs within the `ModalBody`.\n     * - If set to `outside`, the entire `ModalContent` will scroll within the viewport.\n     *\n     * @default \"outside\"\n     */\n    scrollBehavior?: ScrollBehavior;\n    /**\n     * Fires when all exiting nodes have completed animating out\n     */\n    onCloseComplete?: () => void;\n    /**\n     * Props to be forwarded to the portal component\n     */\n    portalProps?: PortalProps;\n}\n\n/**\n * Modal component\n *\n * @See Docs https://dreamy-ui.com/docs/components/modal\n */\nexport const Modal = withProvider(function ModalRoot(props: ModalProps) {\n    const modalProps: ModalProps = {\n        scrollBehavior: \"inside\",\n        autoFocus: true,\n        trapFocus: true,\n        returnFocusOnClose: true,\n        blockScrollOnMount: true,\n        allowPinchZoom: false,\n        preserveScrollBarGap: true,\n        ...props\n    };\n\n    const {\n        children,\n        autoFocus,\n        trapFocus,\n        initialFocusRef,\n        finalFocusRef,\n        returnFocusOnClose,\n        blockScrollOnMount,\n        scrollBehavior,\n        allowPinchZoom,\n        preserveScrollBarGap,\n        onCloseComplete,\n        portalProps\n    } = modalProps;\n\n    const modal = useModal(modalProps);\n\n    // biome-ignore lint/correctness/useExhaustiveDependencies: <explanation>\n    const context = useMemo(() => {\n        return {\n            ...modal,\n            autoFocus,\n            trapFocus,\n            initialFocusRef,\n            finalFocusRef,\n            returnFocusOnClose,\n            blockScrollOnMount,\n            allowPinchZoom,\n            preserveScrollBarGap,\n            onCloseComplete,\n            scrollBehavior\n        };\n    }, [modal]);\n\n    return (\n        <ModalContextProvider value={context}>\n            <AnimatePresence onExitComplete={onCloseComplete}>\n                {context.isOpen && (\n                    <Portal\n                        key={context.id}\n                        {...portalProps}\n                    >\n                        {children}\n                    </Portal>\n                )}\n            </AnimatePresence>\n        </ModalContextProvider>\n    );\n});\n\nexport interface ModalOverlayProps extends MotionBoxProps {}\n\nexport const ModalOverlay = withContext(\n    forwardRef<HTMLDivElement, ModalOverlayProps>((props, ref) => {\n        const { isOpen } = useModalContext();\n        const { overlay } = useMotionVariants();\n\n        return (\n            <AnimatePresence>\n                {isOpen && (\n                    <MotionBox\n                        variants={overlay.default}\n                        initial=\"initial\"\n                        animate=\"animate\"\n                        exit=\"exit\"\n                        ref={ref}\n                        {...props}\n                    />\n                )}\n            </AnimatePresence>\n        );\n    }),\n    \"overlay\"\n);\n\nexport interface ModalContainerProps extends MotionFlexProps {}\n\nexport const ModalContainer = withContext(\n    forwardRef<HTMLDivElement, BoxProps>(({ children, ...props }, ref) => {\n        const { getDialogContainerProps } = useModalContext();\n\n        return <Box {...getDialogContainerProps(props, ref)}>{children}</Box>;\n    }),\n    \"container\"\n);\n\nexport interface ModalContentProps extends MotionFlexProps {}\n\nexport const ModalContent = withContext(\n    forwardRef<HTMLDivElement, MotionFlexProps>(({ children, ...props }, ref) => {\n        const { getDialogProps } = useModalContext();\n        const { modal } = useMotionVariants();\n        const transition = useDefaultTransition();\n\n        return (\n            <>\n                <ModalFocusScope>\n                    <ModalContainer>\n                        <MotionFlex\n                            variants={modal.default}\n                            initial=\"initial\"\n                            animate=\"animate\"\n                            exit=\"exit\"\n                            transition={transition}\n                            {...(getDialogProps(props as any, ref) as any)}\n                        >\n                            {children}\n                        </MotionFlex>\n                    </ModalContainer>\n                </ModalFocusScope>\n            </>\n        );\n    }),\n    \"content\"\n);\n\nexport interface ModalHeaderProps extends FlexProps {}\n\nexport const ModalHeader = withContext(\n    forwardRef<HTMLDivElement, ModalHeaderProps>(({ children, ...props }, ref) => {\n        return (\n            <Flex\n                as={\"header\"}\n                {...props}\n                ref={ref}\n            >\n                {typeof children === \"string\" ? (\n                    <Heading\n                        variant={\"heading\"}\n                        size=\"lg\"\n                    >\n                        {children}\n                    </Heading>\n                ) : (\n                    children\n                )}\n            </Flex>\n        );\n    }),\n    \"header\"\n);\n\nexport interface ModalBodyProps extends FlexProps {}\n\nexport const ModalBody = withContext(\n    forwardRef<HTMLDivElement, ModalBodyProps>(({ children, style, ...props }, ref) => {\n        const { scrollBehavior } = useModalContext();\n\n        return (\n            <Flex\n                ref={ref}\n                {...props}\n                style={{\n                    maxHeight: scrollBehavior === \"inside\" ? \"calc(100vh - 10rem)\" : undefined,\n                    overflow: scrollBehavior === \"inside\" ? \"auto\" : undefined,\n                    ...style\n                }}\n            >\n                {children}\n            </Flex>\n        );\n    }),\n    \"body\"\n);\n\nexport interface ModalFooterProps extends FlexProps {}\n\nexport const ModalFooter = withContext(\n    forwardRef<HTMLDivElement, ModalFooterProps>(({ children, ...props }, ref) => {\n        return (\n            <Flex\n                as={\"footer\"}\n                {...props}\n                ref={ref}\n            >\n                {children}\n            </Flex>\n        );\n    }),\n    \"footer\"\n);\n\nexport interface ModalCloseButtonProps extends CloseButtonProps {}\n\nexport const ModalCloseButton = withContext(\n    forwardRef<HTMLButtonElement, ModalCloseButtonProps>(({ ...props }, ref) => {\n        const { onClose } = useModalContext();\n\n        return (\n            <CloseButton\n                ref={ref}\n                onClick={onClose}\n                {...props}\n            />\n        );\n    }),\n    \"close\"\n);\n\ninterface ModalFocusScopeProps {\n    children: React.ReactElement;\n}\n\nclass ModalManager {\n    modals: Map<HTMLElement, number>;\n    constructor() {\n        this.modals = new Map();\n    }\n\n    add(modal: HTMLElement) {\n        this.modals.set(modal, this.modals.size + 1);\n        return this.modals.size;\n    }\n\n    remove(modal: HTMLElement) {\n        this.modals.delete(modal);\n    }\n\n    isTopModal(modal: HTMLElement | null) {\n        if (!modal) return false;\n        return this.modals.get(modal) === this.modals.size;\n    }\n}\n\nexport const modalManager = new ModalManager();\n\nexport function useModalManager(ref: RefObject<HTMLElement | null>, isOpen?: boolean) {\n    const [index, setIndex] = useState(0);\n\n    useEffect(() => {\n        const node = ref.current;\n\n        if (!node) return;\n\n        if (isOpen) {\n            const index = modalManager.add(node);\n            setIndex(index);\n        }\n\n        return () => {\n            modalManager.remove(node);\n            setIndex(0);\n        };\n    }, [isOpen, ref]);\n\n    return index;\n}\n\nfunction ModalFocusScope(props: ModalFocusScopeProps) {\n    const {\n        autoFocus,\n        trapFocus,\n        dialogRef,\n        initialFocusRef,\n        blockScrollOnMount,\n        allowPinchZoom,\n        finalFocusRef,\n        returnFocusOnClose,\n        preserveScrollBarGap,\n        lockFocusAcrossFrames,\n        useInert,\n        isOpen\n    } = useModalContext();\n\n    const [isPresent, safeToRemove] = usePresence();\n\n    useEffect(() => {\n        if (!isPresent && safeToRemove) {\n            setTimeout(safeToRemove);\n        }\n    }, [isPresent, safeToRemove]);\n\n    const index = useModalManager(dialogRef, isOpen);\n\n    return (\n        <FocusLock\n            autoFocus={autoFocus}\n            isDisabled={!trapFocus}\n            initialFocusRef={initialFocusRef}\n            finalFocusRef={finalFocusRef}\n            restoreFocus={returnFocusOnClose}\n            contentRef={dialogRef}\n            lockFocusAcrossFrames={lockFocusAcrossFrames}\n        >\n            <RemoveScroll\n                removeScrollBar={!preserveScrollBarGap}\n                allowPinchZoom={allowPinchZoom}\n                // only block scroll for first dialog\n                enabled={index === 1 && blockScrollOnMount}\n                forwardProps\n                inert={useInert}\n            >\n                {props.children}\n            </RemoveScroll>\n        </FocusLock>\n    );\n}\n\ninterface ModalOptions {\n    /**\n     * If `false`, focus lock will be disabled completely.\n     *\n     * This is useful in situations where you still need to interact with\n     * other surrounding elements.\n     *\n     * 🚨Warning: We don't recommend doing this because it hurts the\n     * accessibility of the modal, based on WAI-ARIA specifications.\n     *\n     * @default true\n     */\n    trapFocus?: boolean;\n    /**\n     * If `true`, the modal will autofocus the first enabled and interactive\n     * element within the `ModalContent`\n     *\n     * @default true\n     */\n    autoFocus?: boolean;\n    /**\n     * The `ref` of element to receive focus when the modal opens.\n     */\n    initialFocusRef?: React.RefObject<FocusableElement | null>;\n    /**\n     * The `ref` of element to receive focus when the modal closes.\n     */\n    finalFocusRef?: React.RefObject<FocusableElement | null>;\n    /**\n     * If `true`, the modal will return focus to the element that triggered it when it closes.\n     * @default true\n     */\n    returnFocusOnClose?: boolean;\n    /**\n     * If `true`, scrolling will be disabled on the `body` when the modal opens.\n     * @default true\n     */\n    blockScrollOnMount?: boolean;\n    /**\n     * Handle zoom/pinch gestures on iOS devices when scroll locking is enabled.\n     * @default false.\n     */\n    allowPinchZoom?: boolean;\n    /**\n     * If `true`, a `padding-right` will be applied to the body element\n     * that's equal to the width of the scrollbar.\n     *\n     * This can help prevent some unpleasant flickering effect\n     * and content adjustment when the modal opens\n     *\n     * @default true\n     */\n    preserveScrollBarGap?: boolean;\n\n    lockFocusAcrossFrames?: boolean;\n}\n\ntype ScrollBehavior = \"inside\" | \"outside\";\n\nexport interface FocusLockProps {\n    /**\n     * `ref` of the element to receive focus initially\n     */\n    initialFocusRef?: React.RefObject<FocusableElement | null>;\n    /**\n     * `ref` of the element to return focus to when `FocusLock`\n     * unmounts\n     */\n    finalFocusRef?: React.RefObject<FocusableElement | null>;\n    /**\n     * The `ref` of the wrapper for which the focus-lock wraps\n     */\n    contentRef?: React.RefObject<HTMLElement>;\n    /**\n     * If `true`, focus will be restored to the element that\n     * triggered the `FocusLock` once it unmounts\n     *\n     * @default false\n     */\n    restoreFocus?: boolean;\n    /**\n     * If `true`, focus trapping will be disabled\n     *\n     * @default false\n     */\n    disabled?: boolean;\n    /**\n     * If `true`, the first focusable element within the `children`\n     * will auto-focused once `FocusLock` mounts\n     *\n     * @default false\n     */\n    autoFocus?: boolean;\n    /**\n     * If `true`, disables text selections inside, and outside focus lock\n     *\n     * @default false\n     */\n    persistentFocus?: boolean;\n}\n\ninterface FocusableElement {\n    focus(options?: FocusOptions): void;\n}\n"
  },
  "component": "Modal",
  "hasRecipe": true,
  "hasPattern": false,
  "recipeIds": [
    "modal"
  ]
}