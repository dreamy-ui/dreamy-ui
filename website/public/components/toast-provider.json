{
  "type": "component",
  "fileDependencies": [
    "./motion",
    "./toast"
  ],
  "id": "toast-provider",
  "file": {
    "name": "toast-provider.tsx",
    "content": "\"use client\";\r\n\r\nimport { AnimatePresence, type MotionProps, m } from \"motion/react\";\r\nimport {\r\n    Fragment,\r\n    type PropsWithChildren,\r\n    createContext,\r\n    useCallback,\r\n    useContext,\r\n    useMemo,\r\n    useRef,\r\n    useState\r\n} from \"react\";\r\nimport type { MotionBoxProps } from \"./motion\";\r\nimport { Toast } from \"./toast\";\r\n\r\ntype ToastBase = {\r\n    id: string;\r\n    title?: string;\r\n    description?: string;\r\n    status: \"success\" | \"error\" | \"info\" | \"warning\" | \"loading\";\r\n    duration?: number;\r\n    position: Position;\r\n    isClosable?: boolean;\r\n    rightContent?: React.ReactNode;\r\n    onMouseEnter?: () => void;\r\n    onMouseLeave?: () => void;\r\n};\r\n\r\ntype ToastWithRender = ToastBase & {\r\n    render: (toast: ToastWithRender) => React.ReactNode;\r\n    containerProps?: MotionProps;\r\n};\r\n\r\ntype ToastWithoutRender = ToastBase & {\r\n    render?: undefined;\r\n    containerProps?: MotionBoxProps;\r\n};\r\n\r\nexport type IToast = ToastWithRender | ToastWithoutRender;\r\n\r\ninterface ToastContextType {\r\n    toast(toast: Omit<Partial<IToast>, \"id\">): string;\r\n    updateToast(id: string, toast: Partial<IToast>): void;\r\n    removeToast(id: string): void;\r\n    pauseToast(id: string): void;\r\n    resumeToast(id: string): void;\r\n    toasts: IToast[];\r\n}\r\n\r\nconst ToastContext = createContext<ToastContextType | null>(null);\r\n\r\nexport interface ToastProviderProps extends PropsWithChildren {\r\n    defaultToastProps?: Partial<IToast>;\r\n}\r\n\r\nconst emptyObject: Partial<IToast> = {};\r\n\r\nexport function ToastProvider({ children, defaultToastProps = emptyObject }: ToastProviderProps) {\r\n    const [toasts, setToasts] = useState<IToast[]>([]);\r\n    const timeoutsRef = useRef<Map<string, ReturnType<typeof setTimeout>>>(new Map());\r\n    const remainingTimeRef = useRef<Map<string, number>>(new Map());\r\n    const pauseTimeRef = useRef<Map<string, number>>(new Map());\r\n\r\n    const removeToast = useCallback((id: string) => {\r\n        const timeout = timeoutsRef.current.get(id);\r\n        if (timeout) {\r\n            clearTimeout(timeout);\r\n            timeoutsRef.current.delete(id);\r\n        }\r\n        remainingTimeRef.current.delete(id);\r\n        pauseTimeRef.current.delete(id);\r\n        setToasts((prev) => prev.filter((t) => t.id !== id));\r\n    }, []);\r\n\r\n    const pauseToast = useCallback((id: string) => {\r\n        const timeout = timeoutsRef.current.get(id);\r\n        if (timeout) {\r\n            clearTimeout(timeout);\r\n            timeoutsRef.current.delete(id);\r\n\r\n            // Calculate remaining time\r\n            const pauseTime = Date.now();\r\n            const startTime = pauseTimeRef.current.get(id) || pauseTime;\r\n            const elapsed = pauseTime - startTime;\r\n            const currentRemaining = remainingTimeRef.current.get(id) || 0;\r\n            const newRemaining = Math.max(0, currentRemaining - elapsed);\r\n\r\n            remainingTimeRef.current.set(id, newRemaining);\r\n        }\r\n    }, []);\r\n\r\n    const resumeToast = useCallback(\r\n        (id: string) => {\r\n            const remainingTime = remainingTimeRef.current.get(id);\r\n            if (remainingTime && remainingTime > 0) {\r\n                pauseTimeRef.current.set(id, Date.now());\r\n                const timeout = setTimeout(() => removeToast(id), remainingTime);\r\n                timeoutsRef.current.set(id, timeout);\r\n            }\r\n        },\r\n        [removeToast]\r\n    );\r\n\r\n    const toast = useCallback(\r\n        (toast: Omit<Partial<IToast>, \"id\">) => {\r\n            if (!toast.status) {\r\n                toast.status = defaultToastProps.status || \"info\";\r\n            }\r\n\r\n            if (!toast.position) {\r\n                toast.position = defaultToastProps.position || \"bottom-right\";\r\n            }\r\n\r\n            if (!toast.duration) {\r\n                toast.duration = defaultToastProps.duration || 5000;\r\n            }\r\n\r\n            const resolvedRender = (toast.render ?? defaultToastProps.render) as\r\n                | ((toast: ToastWithRender) => React.ReactNode)\r\n                | undefined;\r\n\r\n            if (!toast.isClosable) {\r\n                toast.isClosable = defaultToastProps.isClosable ?? false;\r\n            }\r\n\r\n            if (!toast.rightContent) {\r\n                toast.rightContent = defaultToastProps.rightContent;\r\n            }\r\n\r\n            const id = crypto.randomUUID();\r\n            const duration = toast.duration || 5000;\r\n\r\n            // Add hover handlers to the toast\r\n            const base = {\r\n                ...toast,\r\n                id,\r\n                onMouseEnter: () => pauseToast(id),\r\n                onMouseLeave: () => resumeToast(id)\r\n            };\r\n\r\n            if (typeof resolvedRender === \"function\") {\r\n                const nextToast: ToastWithRender = {\r\n                    ...(base as Omit<ToastWithRender, \"render\">),\r\n                    render: resolvedRender\r\n                };\r\n                setToasts((prev) => [...prev, nextToast]);\r\n            } else {\r\n                const { render: _ignored, ...rest } = base as ToastWithoutRender & {\r\n                    render?: undefined;\r\n                };\r\n                const nextToast: ToastWithoutRender = {\r\n                    ...rest,\r\n                    render: undefined\r\n                };\r\n                setToasts((prev) => [...prev, nextToast]);\r\n            }\r\n\r\n            if (duration !== Number.POSITIVE_INFINITY) {\r\n                // Store initial timing information\r\n                remainingTimeRef.current.set(id, duration);\r\n                pauseTimeRef.current.set(id, Date.now());\r\n\r\n                // Set initial timeout\r\n                const timeout = setTimeout(() => removeToast(id), duration);\r\n                timeoutsRef.current.set(id, timeout);\r\n            }\r\n\r\n            return id;\r\n        },\r\n        [defaultToastProps, pauseToast, resumeToast, removeToast]\r\n    );\r\n\r\n    const updateToast = useCallback(\r\n        (id: string, toast: Partial<IToast>) => {\r\n            if (toast.duration !== undefined) {\r\n                const existingTimeout = timeoutsRef.current.get(id);\r\n                if (existingTimeout) {\r\n                    clearTimeout(existingTimeout);\r\n                    timeoutsRef.current.delete(id);\r\n                }\r\n\r\n                if (toast.duration !== Number.POSITIVE_INFINITY) {\r\n                    remainingTimeRef.current.set(id, toast.duration);\r\n                    pauseTimeRef.current.set(id, Date.now());\r\n                    const timeout = setTimeout(() => removeToast(id), toast.duration);\r\n                    timeoutsRef.current.set(id, timeout);\r\n                }\r\n            }\r\n\r\n            setToasts((prev) =>\r\n                prev.map((t) => (t.id === id ? { ...t, ...(toast as IToast) } : t))\r\n            );\r\n        },\r\n        [removeToast]\r\n    );\r\n\r\n    const contextValue = useMemo(\r\n        () => ({\r\n            toast,\r\n            updateToast,\r\n            removeToast,\r\n            pauseToast,\r\n            resumeToast,\r\n            toasts\r\n        }),\r\n        [toast, updateToast, removeToast, pauseToast, resumeToast, toasts]\r\n    );\r\n\r\n    return (\r\n        <ToastContext.Provider value={contextValue}>\r\n            {children}\r\n            <ToastManager />\r\n        </ToastContext.Provider>\r\n    );\r\n}\r\n\r\nexport function useToast(): ToastContextType {\r\n    const context = useContext(ToastContext);\r\n    if (!context) throw new Error(\"useToast must be used within a ToastProvider\");\r\n    return context;\r\n}\r\n\r\nexport const positions = [\r\n    \"top\",\r\n    \"top-left\",\r\n    \"top-right\",\r\n    \"bottom\",\r\n    \"bottom-left\",\r\n    \"bottom-right\"\r\n] as const;\r\n\r\nexport type Position = (typeof positions)[number];\r\n\r\nexport function ToastManager() {\r\n    const { toasts } = useToast();\r\n\r\n    const groupedToasts = useMemo(\r\n        () =>\r\n            positions.reduce(\r\n                (acc, position) => {\r\n                    acc[position] = toasts.filter((toast) => toast.position === position);\r\n                    return acc;\r\n                },\r\n                {} as Record<Position, IToast[]>\r\n            ),\r\n        [toasts]\r\n    );\r\n\r\n    return (\r\n        <>\r\n            {positions.map((position) => (\r\n                <Fragment key={`${position}-toast-container`}>\r\n                    <AnimatePresence>\r\n                        {!!groupedToasts[position].length && (\r\n                            <m.div\r\n                                key={`${position}-toast-container`}\r\n                                style={{\r\n                                    position: \"fixed\",\r\n                                    top: position.includes(\"top\") ? 0 : undefined,\r\n                                    left:\r\n                                        position.includes(\"left\") ||\r\n                                        [\"bottom\", \"top\"].includes(position)\r\n                                            ? 0\r\n                                            : undefined,\r\n                                    right:\r\n                                        position.includes(\"right\") ||\r\n                                        [\"bottom\", \"top\"].includes(position)\r\n                                            ? 0\r\n                                            : undefined,\r\n                                    bottom: position.includes(\"bottom\") ? 0 : undefined,\r\n                                    display: \"flex\",\r\n                                    flexDirection: \"column\",\r\n                                    alignItems: [\"bottom\", \"top\"].includes(position)\r\n                                        ? \"center\"\r\n                                        : position.includes(\"left\")\r\n                                          ? \"flex-start\"\r\n                                          : \"flex-end\",\r\n                                    gap: \"8px\",\r\n                                    padding: \"1rem\",\r\n                                    zIndex: \"var(--z-index-toast)\",\r\n                                    pointerEvents: \"none\"\r\n                                }}\r\n                            >\r\n                                <AnimatePresence propagate={groupedToasts[position].length <= 1}>\r\n                                    {groupedToasts[position].map((toast) => (\r\n                                        <Toast\r\n                                            key={toast.id}\r\n                                            toast={toast}\r\n                                        />\r\n                                    ))}\r\n                                </AnimatePresence>\r\n                            </m.div>\r\n                        )}\r\n                    </AnimatePresence>\r\n                </Fragment>\r\n            ))}\r\n        </>\r\n    );\r\n}\r\n"
  },
  "component": "ToastProvider",
  "hasRecipe": false,
  "hasPattern": false
}