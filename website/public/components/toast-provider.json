{
  "type": "component",
  "fileDependencies": [
    "./motion",
    "./toast"
  ],
  "id": "toast-provider",
  "file": {
    "name": "toast-provider.tsx",
    "content": "\"use client\";\n\nimport { AnimatePresence, type MotionProps, m } from \"motion/react\";\nimport {\n    Fragment,\n    type PropsWithChildren,\n    createContext,\n    useCallback,\n    useContext,\n    useMemo,\n    useRef,\n    useState\n} from \"react\";\nimport type { MotionBoxProps } from \"./motion\";\nimport { Toast } from \"./toast\";\n\ntype ToastBase = {\n    id: string;\n    title?: string;\n    description?: string;\n    status: \"success\" | \"error\" | \"info\" | \"warning\" | \"loading\";\n    duration?: number;\n    position: Position;\n    isClosable?: boolean;\n    rightContent?: React.ReactNode;\n    onMouseEnter?: () => void;\n    onMouseLeave?: () => void;\n};\n\ntype ToastWithRender = ToastBase & {\n    render: (toast: ToastWithRender) => React.ReactNode;\n    containerProps?: MotionProps;\n};\n\ntype ToastWithoutRender = ToastBase & {\n    render?: undefined;\n    containerProps?: MotionBoxProps;\n};\n\nexport type IToast = ToastWithRender | ToastWithoutRender;\n\ninterface ToastContextType {\n    toast(toast: Omit<Partial<IToast>, \"id\">): string;\n    updateToast(id: string, toast: Partial<IToast>): void;\n    removeToast(id: string): void;\n    pauseToast(id: string): void;\n    resumeToast(id: string): void;\n    toasts: IToast[];\n}\n\nconst ToastContext = createContext<ToastContextType | null>(null);\n\nexport interface ToastProviderProps extends PropsWithChildren {\n    defaultToastProps?: Partial<IToast>;\n}\n\nconst emptyObject: Partial<IToast> = {};\n\nexport function ToastProvider({ children, defaultToastProps = emptyObject }: ToastProviderProps) {\n    const [toasts, setToasts] = useState<IToast[]>([]);\n    const timeoutsRef = useRef<Map<string, ReturnType<typeof setTimeout>>>(new Map());\n    const remainingTimeRef = useRef<Map<string, number>>(new Map());\n    const pauseTimeRef = useRef<Map<string, number>>(new Map());\n\n    const removeToast = useCallback((id: string) => {\n        const timeout = timeoutsRef.current.get(id);\n        if (timeout) {\n            clearTimeout(timeout);\n            timeoutsRef.current.delete(id);\n        }\n        remainingTimeRef.current.delete(id);\n        pauseTimeRef.current.delete(id);\n        setToasts((prev) => prev.filter((t) => t.id !== id));\n    }, []);\n\n    const pauseToast = useCallback((id: string) => {\n        const timeout = timeoutsRef.current.get(id);\n        if (timeout) {\n            clearTimeout(timeout);\n            timeoutsRef.current.delete(id);\n\n            // Calculate remaining time\n            const pauseTime = Date.now();\n            const startTime = pauseTimeRef.current.get(id) || pauseTime;\n            const elapsed = pauseTime - startTime;\n            const currentRemaining = remainingTimeRef.current.get(id) || 0;\n            const newRemaining = Math.max(0, currentRemaining - elapsed);\n\n            remainingTimeRef.current.set(id, newRemaining);\n        }\n    }, []);\n\n    const resumeToast = useCallback(\n        (id: string) => {\n            const remainingTime = remainingTimeRef.current.get(id);\n            if (remainingTime && remainingTime > 0) {\n                pauseTimeRef.current.set(id, Date.now());\n                const timeout = setTimeout(() => removeToast(id), remainingTime);\n                timeoutsRef.current.set(id, timeout);\n            }\n        },\n        [removeToast]\n    );\n\n    const toast = useCallback(\n        (toast: Omit<Partial<IToast>, \"id\">) => {\n            if (!toast.status) {\n                toast.status = defaultToastProps.status || \"info\";\n            }\n\n            if (!toast.position) {\n                toast.position = defaultToastProps.position || \"bottom-right\";\n            }\n\n            if (!toast.duration) {\n                toast.duration = defaultToastProps.duration || 5000;\n            }\n\n            const resolvedRender = (toast.render ?? defaultToastProps.render) as\n                | ((toast: ToastWithRender) => React.ReactNode)\n                | undefined;\n\n            if (!toast.isClosable) {\n                toast.isClosable = defaultToastProps.isClosable ?? false;\n            }\n\n            if (!toast.rightContent) {\n                toast.rightContent = defaultToastProps.rightContent;\n            }\n\n            const id = crypto.randomUUID();\n            const duration = toast.duration || 5000;\n\n            // Add hover handlers to the toast\n            const base = {\n                ...toast,\n                id,\n                onMouseEnter: () => pauseToast(id),\n                onMouseLeave: () => resumeToast(id)\n            };\n\n            if (typeof resolvedRender === \"function\") {\n                const nextToast: ToastWithRender = {\n                    ...(base as Omit<ToastWithRender, \"render\">),\n                    render: resolvedRender\n                };\n                setToasts((prev) => [...prev, nextToast]);\n            } else {\n                const { render: _ignored, ...rest } = base as ToastWithoutRender & {\n                    render?: undefined;\n                };\n                const nextToast: ToastWithoutRender = {\n                    ...rest,\n                    render: undefined\n                };\n                setToasts((prev) => [...prev, nextToast]);\n            }\n\n            if (duration !== Number.POSITIVE_INFINITY) {\n                // Store initial timing information\n                remainingTimeRef.current.set(id, duration);\n                pauseTimeRef.current.set(id, Date.now());\n\n                // Set initial timeout\n                const timeout = setTimeout(() => removeToast(id), duration);\n                timeoutsRef.current.set(id, timeout);\n            }\n\n            return id;\n        },\n        [defaultToastProps, pauseToast, resumeToast, removeToast]\n    );\n\n    const updateToast = useCallback(\n        (id: string, toast: Partial<IToast>) => {\n            if (toast.duration !== undefined) {\n                const existingTimeout = timeoutsRef.current.get(id);\n                if (existingTimeout) {\n                    clearTimeout(existingTimeout);\n                    timeoutsRef.current.delete(id);\n                }\n\n                if (toast.duration !== Number.POSITIVE_INFINITY) {\n                    remainingTimeRef.current.set(id, toast.duration);\n                    pauseTimeRef.current.set(id, Date.now());\n                    const timeout = setTimeout(() => removeToast(id), toast.duration);\n                    timeoutsRef.current.set(id, timeout);\n                }\n            }\n\n            setToasts((prev) =>\n                prev.map((t) => (t.id === id ? { ...t, ...(toast as IToast) } : t))\n            );\n        },\n        [removeToast]\n    );\n\n    const contextValue = useMemo(\n        () => ({\n            toast,\n            updateToast,\n            removeToast,\n            pauseToast,\n            resumeToast,\n            toasts\n        }),\n        [toast, updateToast, removeToast, pauseToast, resumeToast, toasts]\n    );\n\n    return (\n        <ToastContext.Provider value={contextValue}>\n            {children}\n            <ToastManager />\n        </ToastContext.Provider>\n    );\n}\n\nexport function useToast(): ToastContextType {\n    const context = useContext(ToastContext);\n    if (!context) throw new Error(\"useToast must be used within a ToastProvider\");\n    return context;\n}\n\nexport const positions = [\n    \"top\",\n    \"top-left\",\n    \"top-right\",\n    \"bottom\",\n    \"bottom-left\",\n    \"bottom-right\"\n] as const;\n\nexport type Position = (typeof positions)[number];\n\nexport function ToastManager() {\n    const { toasts } = useToast();\n\n    const groupedToasts = useMemo(\n        () =>\n            positions.reduce(\n                (acc, position) => {\n                    acc[position] = toasts.filter((toast) => toast.position === position);\n                    return acc;\n                },\n                {} as Record<Position, IToast[]>\n            ),\n        [toasts]\n    );\n\n    return (\n        <>\n            {positions.map((position) => (\n                <Fragment key={`${position}-toast-container`}>\n                    <AnimatePresence>\n                        {!!groupedToasts[position].length && (\n                            <m.div\n                                key={`${position}-toast-container`}\n                                style={{\n                                    position: \"fixed\",\n                                    top: position.includes(\"top\") ? 0 : undefined,\n                                    left:\n                                        position.includes(\"left\") ||\n                                        [\"bottom\", \"top\"].includes(position)\n                                            ? 0\n                                            : undefined,\n                                    right:\n                                        position.includes(\"right\") ||\n                                        [\"bottom\", \"top\"].includes(position)\n                                            ? 0\n                                            : undefined,\n                                    bottom: position.includes(\"bottom\") ? 0 : undefined,\n                                    display: \"flex\",\n                                    flexDirection: \"column\",\n                                    alignItems: [\"bottom\", \"top\"].includes(position)\n                                        ? \"center\"\n                                        : position.includes(\"left\")\n                                          ? \"flex-start\"\n                                          : \"flex-end\",\n                                    gap: \"8px\",\n                                    padding: \"1rem\",\n                                    zIndex: \"var(--z-index-toast)\",\n                                    pointerEvents: \"none\"\n                                }}\n                            >\n                                <AnimatePresence propagate={groupedToasts[position].length <= 1}>\n                                    {groupedToasts[position].map((toast) => (\n                                        <Toast\n                                            key={toast.id}\n                                            toast={toast}\n                                        />\n                                    ))}\n                                </AnimatePresence>\n                            </m.div>\n                        )}\n                    </AnimatePresence>\n                </Fragment>\n            ))}\n        </>\n    );\n}\n"
  },
  "component": "ToastProvider",
  "hasRecipe": false,
  "hasPattern": false
}