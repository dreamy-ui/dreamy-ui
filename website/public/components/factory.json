{
  "type": "component",
  "fileDependencies": [],
  "id": "factory",
  "file": {
    "name": "factory.ts",
    "content": "import type React from \"react\";\nimport {\n\tChildren,\n\ttype ComponentPropsWithoutRef,\n\ttype ElementType,\n\ttype FunctionComponent,\n\tcloneElement,\n\tcreateElement,\n\tforwardRef,\n\tisValidElement,\n\tmemo\n} from \"react\";\nimport { styled } from \"styled-system/jsx\";\nimport type {\n\tAssign,\n\tDistributiveOmit,\n\tDistributiveUnion,\n\tJsxRecipeProps,\n\tJsxStyleProps,\n\tPretty,\n\tRecipeDefinition,\n\tRecipeSelection,\n\tRecipeVariantRecord\n} from \"styled-system/types\";\n\ntype DreamPropsWithRef<E extends React.ElementType> =\n\tReact.ComponentPropsWithRef<E>;\n\ninterface RecipeFn {\n\t__type: any;\n}\n\ninterface JsxFactoryOptions<TProps extends Dict> {\n\tdataAttr?: boolean;\n\tdefaultProps?: TProps;\n\tshouldForwardProp?(prop: string, variantKeys: string[]): boolean;\n}\n\nfunction withAsProps(Component: React.ElementType) {\n\tconst Comp = memo(\n\t\tforwardRef<unknown, DreamPropsWithRef<typeof Component>>(\n\t\t\t(props: DreamPropsWithRef<typeof Component>, ref) => {\n\t\t\t\tconst { asChild, asComp, children, ...restProps } = props;\n\n\t\t\t\tif (asComp) {\n\t\t\t\t\treturn createElement(\n\t\t\t\t\t\tasComp.type,\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\t...restProps,\n\t\t\t\t\t\t\t...asComp.props,\n\t\t\t\t\t\t\tref:\n\t\t\t\t\t\t\t\t\"ref\" in asComp\n\t\t\t\t\t\t\t\t\t? composeRefs(ref, asComp.ref)\n\t\t\t\t\t\t\t\t\t: ref\n\t\t\t\t\t\t},\n\t\t\t\t\t\tchildren\n\t\t\t\t\t);\n\t\t\t\t}\n\n\t\t\t\tif (!asChild) {\n\t\t\t\t\treturn createElement(\n\t\t\t\t\t\tComponent,\n\t\t\t\t\t\t{ ...restProps, ref },\n\t\t\t\t\t\tchildren\n\t\t\t\t\t);\n\t\t\t\t}\n\n\t\t\t\tconst onlyChild = Children.only(children) as React.ReactElement;\n\n\t\t\t\tif (!isValidElement(onlyChild)) {\n\t\t\t\t\treturn null;\n\t\t\t\t}\n\n\t\t\t\tconst childRef = getRef(onlyChild);\n\n\t\t\t\treturn cloneElement(onlyChild, {\n\t\t\t\t\t...restProps,\n\t\t\t\t\t...(onlyChild.props as object),\n\t\t\t\t\tref: ref ? composeRefs(ref, childRef) : childRef\n\t\t\t\t});\n\t\t\t}\n\t\t)\n\t);\n\n\t// @ts-expect-error - it exists\n\tComp.displayName = Component.displayName || Component.name;\n\n\treturn Comp;\n}\n\nexport type JsxElement<\n\tT extends ElementType,\n\tP extends Dict\n> = T extends DreamComponent<infer A, infer B>\n\t? DreamComponent<A, Pretty<DistributiveUnion<P, B>>>\n\t: DreamComponent<T, P>;\n\ninterface DreamFactory {\n\t<T extends ElementType>(component: T): DreamComponent<T, {}>;\n\t<T extends ElementType, P extends RecipeVariantRecord>(\n\t\tcomponent: T,\n\t\trecipe: RecipeDefinition<P>,\n\t\toptions?: JsxFactoryOptions<JsxRecipeProps<T, RecipeSelection<P>>>\n\t): JsxElement<T, RecipeSelection<P>>;\n\t<T extends ElementType, P extends RecipeFn>(\n\t\tcomponent: T,\n\t\trecipeFn: P,\n\t\toptions?: JsxFactoryOptions<JsxRecipeProps<T, P[\"__type\"]>>\n\t): JsxElement<T, P[\"__type\"]>;\n}\n\ntype JsxElements = {\n\t[K in keyof React.JSX.IntrinsicElements]: DreamComponent<K, {}>;\n};\n\nexport type Dreamy = DreamFactory & JsxElements;\n\nfunction styledWithAsProps<\n\tT extends ElementType,\n\tP extends RecipeVariantRecord\n>(\n\tComponent: T,\n\trecipe?: RecipeDefinition<P>,\n\toptions?: JsxFactoryOptions<JsxRecipeProps<T, RecipeSelection<P>>>\n): DreamComponent<T, {}>;\nfunction styledWithAsProps<T extends ElementType, P extends RecipeFn>(\n\tComponent: T,\n\trecipe?: P,\n\toptions?: JsxFactoryOptions<JsxRecipeProps<T, P[\"__type\"]>>\n): DreamComponent<T, P[\"__type\"]> {\n\treturn styled(withAsProps(Component), recipe as any, options) as any;\n}\n\nfunction createJsxFactory() {\n\tconst cache = new Map<DOMElements, DreamComponent<DOMElements>>();\n\n\treturn new Proxy(styledWithAsProps, {\n\t\tapply(\n\t\t\t_,\n\t\t\t__,\n\t\t\targs: [\n\t\t\t\tDOMElements,\n\t\t\t\tRecipeDefinition<RecipeVariantRecord>,\n\t\t\t\tJsxFactoryOptions<\n\t\t\t\t\tJsxRecipeProps<\n\t\t\t\t\t\tDOMElements,\n\t\t\t\t\t\tRecipeSelection<RecipeVariantRecord>\n\t\t\t\t\t>\n\t\t\t\t>\n\t\t\t]\n\t\t) {\n\t\t\treturn styledWithAsProps(...args);\n\t\t},\n\t\tget(_, el: DOMElements) {\n\t\t\tif (!cache.has(el)) {\n\t\t\t\tcache.set(el, styledWithAsProps(el, undefined, undefined));\n\t\t\t}\n\t\t\treturn cache.get(el);\n\t\t}\n\t}) as unknown as Dreamy;\n}\n\nexport const dreamy = createJsxFactory();\n\nexport function getRef(child: React.ReactElement) {\n\tif (\"ref\" in (child?.props as object))\n\t\treturn (child.props as { ref: React.Ref<unknown> }).ref;\n\tif (\"ref\" in child) return child.ref;\n\treturn null;\n}\n\ntype PossibleRef<T> = React.Ref<T> | unknown | undefined;\n\nexport function setRef<T>(ref: PossibleRef<T>, value: T) {\n\tif (typeof ref === \"function\") {\n\t\tref(value);\n\t} else if (ref !== null && ref !== undefined) {\n\t\t(ref as React.MutableRefObject<T>).current = value;\n\t}\n}\n\nexport function composeRefs<T>(...refs: PossibleRef<T>[]) {\n\treturn (node: T) => {\n\t\tfor (const ref of refs) {\n\t\t\tsetRef(ref, node);\n\t\t}\n\t};\n}\n\ninterface HtmlProps {\n\thtmlSize?: number;\n\thtmlWidth?: string | number;\n\thtmlHeight?: string | number;\n\thtmlTranslate?: \"yes\" | \"no\" | undefined;\n\thtmlContent?: string;\n}\n\nexport type HtmlProp =\n\t| \"color\"\n\t| \"size\"\n\t| \"translate\"\n\t| \"transition\"\n\t| \"width\"\n\t| \"height\"\n\t| \"content\";\n\nexport interface PolymorphicProps {\n\tas?: ElementType;\n\tasChild?: boolean;\n\tasComp?: React.ReactNode;\n}\n\ntype PatchHtmlProps<T> = DistributiveOmit<T, HtmlProp> & HtmlProps;\n\ntype AssignHtmlProps<T extends Dict, P extends Dict = {}> = Assign<\n\tPatchHtmlProps<T>,\n\tP\n>;\n\nexport type HTMLDreamyProps<\n\tT extends ElementType,\n\tP extends Dict = {}\n> = AssignHtmlProps<\n\tComponentPropsWithoutRef<T>,\n\tAssign<JsxStyleProps, P> & PolymorphicProps\n>;\n\nexport type AnyFunction<T = any> = (...args: T[]) => any;\n\nexport type Merge<M, N> = N extends Record<string, unknown>\n\t? M\n\t: Omit<M, keyof N> & N;\n\nexport interface FocusableElement {\n\tfocus(options?: FocusOptions): void;\n}\n\nexport type Dict<T = any> = Record<string, T>;\n\nexport type DOMElements = keyof React.JSX.IntrinsicElements;\n\nexport type HTMLDreamyComponents = {\n\t[Tag in DOMElements]: DreamComponent<React.ComponentType<Tag>, {}>;\n};\n\nexport type DreamComponent<\n\tT extends ElementType,\n\tP extends Dict = {}\n> = FunctionComponent<HTMLDreamyProps<T, P> & { ref?: any }>;\n\nexport type Status = \"info\" | \"warning\" | \"error\" | \"success\";\n"
  },
  "component": "Factory",
  "hasRecipe": false,
  "hasPattern": false
}