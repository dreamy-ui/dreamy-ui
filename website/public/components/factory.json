{
  "type": "component",
  "fileDependencies": [],
  "id": "factory",
  "file": {
    "name": "factory.ts",
    "content": "import type React from \"react\";\nimport {\n    Children,\n    type ComponentPropsWithoutRef,\n    type ElementType,\n    type FunctionComponent,\n    cloneElement,\n    createElement,\n    forwardRef,\n    isValidElement,\n    memo\n} from \"react\";\nimport { dreamy as styled } from \"styled-system/jsx\";\nimport type {\n    Assign,\n    DistributiveOmit,\n    DistributiveUnion,\n    JsxRecipeProps,\n    JsxStyleProps,\n    Pretty,\n    RecipeDefinition,\n    RecipeSelection,\n    RecipeVariantRecord,\n    UnstyledProps\n} from \"styled-system/types\";\n\ntype DreamPropsWithRef<E extends React.ElementType> = React.ComponentPropsWithRef<E>;\n\ninterface RecipeFn {\n    __type: any;\n}\n\ninterface JsxFactoryOptions<TProps extends Dict> {\n    dataAttr?: boolean;\n    defaultProps?: TProps;\n    shouldForwardProp?(prop: string, variantKeys: string[]): boolean;\n}\n\nfunction withAsProps(Component: React.ElementType) {\n    const Comp = memo(\n        forwardRef<unknown, DreamPropsWithRef<typeof Component>>(\n            (props: DreamPropsWithRef<typeof Component>, ref) => {\n                const { asChild, asComp, children, ...restProps } = props;\n\n                if (asComp) {\n                    return createElement(\n                        asComp.type,\n                        {\n                            ...restProps,\n                            ...asComp.props,\n                            ref: \"ref\" in asComp ? composeRefs(ref, asComp.ref) : ref\n                        },\n                        children\n                    );\n                }\n\n                if (!asChild) {\n                    return createElement(Component, { ...restProps, ref }, children);\n                }\n\n                const onlyChild = Children.only(children) as React.ReactElement;\n\n                if (!isValidElement(onlyChild)) {\n                    return null;\n                }\n\n                const childRef = getRef(onlyChild);\n\n                return cloneElement(onlyChild, {\n                    ...restProps,\n                    ...(onlyChild.props as object),\n                    ref: ref ? composeRefs(ref, childRef) : childRef\n                });\n            }\n        )\n    );\n\n    // @ts-expect-error - it exists\n    Comp.displayName = Component.displayName || Component.name;\n\n    return Comp;\n}\n\nexport type JsxElement<T extends ElementType, P extends Dict> = T extends DreamyComponent<\n    infer A,\n    infer B\n>\n    ? DreamyComponent<A, Pretty<DistributiveUnion<P, B>>>\n    : DreamyComponent<T, P>;\n\ninterface DreamFactory {\n    <T extends ElementType>(component: T): DreamyComponent<T, {}>;\n    <T extends ElementType, P extends RecipeVariantRecord>(\n        component: T,\n        recipe: RecipeDefinition<P>,\n        options?: JsxFactoryOptions<JsxRecipeProps<T, RecipeSelection<P>>>\n    ): JsxElement<T, RecipeSelection<P>>;\n    <T extends ElementType, P extends RecipeFn>(\n        component: T,\n        recipeFn: P,\n        options?: JsxFactoryOptions<JsxRecipeProps<T, P[\"__type\"]>>\n    ): JsxElement<T, P[\"__type\"]>;\n}\n\ntype JsxElements = {\n    [K in keyof React.JSX.IntrinsicElements]: DreamyComponent<K, {}>;\n};\n\nexport type Dreamy = DreamFactory & JsxElements;\n\nfunction styledWithAsProps<T extends ElementType, P extends RecipeVariantRecord>(\n    Component: T,\n    recipe?: RecipeDefinition<P>,\n    options?: JsxFactoryOptions<JsxRecipeProps<T, RecipeSelection<P>>>\n): DreamyComponent<T, {}>;\nfunction styledWithAsProps<T extends ElementType, P extends RecipeFn>(\n    Component: T,\n    recipe?: P,\n    options?: JsxFactoryOptions<JsxRecipeProps<T, P[\"__type\"]>>\n): DreamyComponent<T, P[\"__type\"]> {\n    return styled(withAsProps(Component), recipe as any, options) as any;\n}\n\nfunction createJsxFactory() {\n    const cache = new Map<DOMElements, DreamyComponent<DOMElements>>();\n\n    return new Proxy(styledWithAsProps, {\n        apply(\n            _,\n            __,\n            args: [\n                DOMElements,\n                RecipeDefinition<RecipeVariantRecord>,\n                JsxFactoryOptions<JsxRecipeProps<DOMElements, RecipeSelection<RecipeVariantRecord>>>\n            ]\n        ) {\n            return styledWithAsProps(...args);\n        },\n        get(_, el: DOMElements) {\n            if (!cache.has(el)) {\n                cache.set(el, styledWithAsProps(el, undefined, undefined));\n            }\n            return cache.get(el);\n        }\n    }) as unknown as Dreamy;\n}\n\nexport const dreamy = createJsxFactory();\n\nexport function getRef(child: React.ReactElement) {\n    if (\"ref\" in (child?.props as object)) return (child.props as { ref: React.Ref<unknown> }).ref;\n    if (\"ref\" in child) return child.ref;\n    return null;\n}\n\ntype PossibleRef<T> = React.Ref<T> | unknown | undefined;\n\nexport function setRef<T>(ref: PossibleRef<T>, value: T) {\n    if (typeof ref === \"function\") {\n        ref(value);\n    } else if (ref !== null && ref !== undefined) {\n        (ref as React.MutableRefObject<T>).current = value;\n    }\n}\n\nexport function composeRefs<T>(...refs: PossibleRef<T>[]) {\n    return (node: T) => {\n        for (const ref of refs) {\n            setRef(ref, node);\n        }\n    };\n}\n\ninterface HtmlProps {\n    htmlSize?: number;\n    htmlWidth?: string | number;\n    htmlHeight?: string | number;\n    htmlTranslate?: \"yes\" | \"no\" | undefined;\n    htmlContent?: string;\n}\n\nexport type HtmlProp =\n    | \"color\"\n    | \"size\"\n    | \"translate\"\n    | \"transition\"\n    | \"width\"\n    | \"height\"\n    | \"content\";\n\nexport interface PolymorphicProps {\n    as?: ElementType;\n    asChild?: boolean;\n    asComp?: React.ReactNode;\n}\n\ntype PatchHtmlProps<T> = DistributiveOmit<T, HtmlProp> & HtmlProps;\n\ntype AssignHtmlProps<T extends Dict, P extends Dict = {}> = Assign<PatchHtmlProps<T>, P>;\n\ntype DataAttrProps = {\n    [K in `data-${string}`]?: string;\n};\n\ntype AriaAttrProps = {\n    [K in `aria-${string}`]?: string;\n};\n\nexport type HTMLDreamyProps<T extends ElementType, P extends Dict = {}> = AssignHtmlProps<\n    ComponentPropsWithoutRef<T>,\n    Assign<JsxStyleProps, P> & PolymorphicProps & UnstyledProps & DataAttrProps & AriaAttrProps\n>;\n\nexport type AnyFunction<T = any> = (...args: T[]) => any;\n\nexport type Merge<M, N> = N extends Record<string, unknown> ? M : Omit<M, keyof N> & N;\n\nexport interface FocusableElement {\n    focus(options?: FocusOptions): void;\n}\n\nexport type Dict<T = any> = Record<string, T>;\n\nexport type DOMElements = keyof React.JSX.IntrinsicElements;\n\nexport type HTMLDreamyComponents = {\n    [Tag in DOMElements]: DreamyComponent<React.ComponentType<Tag>, {}>;\n};\n\nexport type DreamyComponent<T extends ElementType, P extends Dict = {}> = FunctionComponent<\n    HTMLDreamyProps<T, P> & { ref?: any }\n>;\n\nexport type Status = \"info\" | \"warning\" | \"error\" | \"success\";\n"
  },
  "component": "Factory",
  "hasRecipe": false,
  "hasPattern": false
}