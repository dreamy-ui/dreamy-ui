{
  "type": "component",
  "fileDependencies": [],
  "id": "factory",
  "file": {
    "name": "factory.ts",
    "content": "import { objectToDeps } from \"@dreamy-ui/react\";\r\nimport type React from \"react\";\r\nimport {\r\n    type ComponentPropsWithoutRef,\r\n    type ElementType,\r\n    type FunctionComponent,\r\n    createElement,\r\n    forwardRef,\r\n    useMemo\r\n} from \"react\";\r\nimport { css, cva, cx } from \"styled-system/css\";\r\nimport { splitProps } from \"styled-system/helpers\";\r\nimport { isCssProperty } from \"styled-system/jsx\";\r\nimport type {\r\n    Assign,\r\n    DistributiveOmit,\r\n    DistributiveUnion,\r\n    JsxRecipeProps,\r\n    JsxStyleProps,\r\n    Pretty,\r\n    RecipeDefinition,\r\n    RecipeSelection,\r\n    RecipeVariantRecord,\r\n    UnstyledProps\r\n} from \"styled-system/types\";\r\n\r\ntype DreamPropsWithRef<E extends React.ElementType> = React.ComponentPropsWithRef<E>;\r\n\r\ninterface RecipeFn {\r\n    __type: any;\r\n}\r\n\r\ninterface JsxFactoryOptions<TProps extends Dict> {\r\n    dataAttr?: boolean;\r\n    defaultProps?: TProps;\r\n    shouldForwardProp?(prop: string, variantKeys: string[]): boolean;\r\n}\r\n\r\n// function withAsProps(Component: React.ElementType) {\r\n//     const Comp = memo(\r\n//         forwardRef<unknown, DreamPropsWithRef<typeof Component>>(\r\n//             (props: DreamPropsWithRef<typeof Component>, ref) => {\r\n//                 const { asChild, asComp, children, ...restProps } = props;\r\n\r\n//                 if (asComp) {\r\n//                     return createElement(\r\n//                         asComp.type,\r\n//                         {\r\n//                             ...restProps,\r\n//                             ...asComp.props,\r\n//                             ref: \"ref\" in asComp ? composeRefs(ref, asComp.ref) : ref\r\n//                         },\r\n//                         children\r\n//                     );\r\n//                 }\r\n\r\n//                 if (!asChild) {\r\n//                     return createElement(Component, { ...restProps, ref }, children);\r\n//                 }\r\n\r\n//                 const onlyChild = Children.only(children) as React.ReactElement;\r\n\r\n//                 if (!isValidElement(onlyChild)) {\r\n//                     return null;\r\n//                 }\r\n\r\n//                 const childRef = getRef(onlyChild);\r\n\r\n//                 return cloneElement(onlyChild, {\r\n//                     ...restProps,\r\n//                     ...(onlyChild.props as object),\r\n//                     ref: ref ? composeRefs(ref, childRef) : childRef\r\n//                 });\r\n//             }\r\n//         )\r\n//     );\r\n\r\n//     // @ts-expect-error - it exists\r\n//     Comp.displayName = Component.displayName || Component.name;\r\n\r\n//     return Comp;\r\n// }\r\n\r\nconst htmlProps = [\"htmlSize\", \"htmlTranslate\", \"htmlWidth\", \"htmlHeight\"];\r\nfunction convert(key: string) {\r\n    return htmlProps.includes(key) ? key.replace(\"html\", \"\").toLowerCase() : key;\r\n}\r\nfunction normalizeHTMLProps(props: any) {\r\n    return Object.fromEntries(Object.entries(props).map(([key, value]) => [convert(key), value]));\r\n}\r\nnormalizeHTMLProps.keys = htmlProps;\r\n\r\nexport const defaultShouldForwardProp = (prop: string, variantKeys: string[]) =>\r\n    !variantKeys.includes(prop) && !isCssProperty(prop);\r\n\r\nconst composeShouldForwardProps = (tag: any, shouldForwardProp: any) =>\r\n    tag.__shouldForwardProps__ && shouldForwardProp\r\n        ? (propName: string) => tag.__shouldForwardProps__(propName) && shouldForwardProp(propName)\r\n        : shouldForwardProp;\r\n\r\nconst composeCvaFn = (cvaA: any, cvaB: any) => {\r\n    if (cvaA && !cvaB) return cvaA;\r\n    if (!cvaA && cvaB) return cvaB;\r\n    if ((cvaA.__cva__ && cvaB.__cva__) || (cvaA.__recipe__ && cvaB.__recipe__))\r\n        return cvaA.merge(cvaB);\r\n    const error = new TypeError(\"Cannot merge cva with recipe. Please use either cva or recipe.\");\r\n    TypeError.captureStackTrace?.(error);\r\n    throw error;\r\n};\r\n\r\nconst getDisplayName = (Component: any) => {\r\n    if (typeof Component === \"string\") return Component;\r\n    return Component?.displayName || Component?.name || \"Component\";\r\n};\r\n\r\nfunction styledFn(Dynamic: any, configOrCva: any = {}, options: any = {}) {\r\n    const cvaFn = configOrCva.__cva__ || configOrCva.__recipe__ ? configOrCva : cva(configOrCva);\r\n\r\n    const forwardFn = options.shouldForwardProp || defaultShouldForwardProp;\r\n    const shouldForwardProp = (prop: string) => {\r\n        if (options.forwardProps?.includes(prop)) return true;\r\n        return forwardFn(prop, cvaFn.variantKeys);\r\n    };\r\n\r\n    const defaultProps = Object.assign(\r\n        options.dataAttr && configOrCva.__name__ ? { \"data-recipe\": configOrCva.__name__ } : {},\r\n        options.defaultProps\r\n    );\r\n\r\n    const __cvaFn__ = composeCvaFn(Dynamic?.__cva__, cvaFn);\r\n    const __shouldForwardProps__ = composeShouldForwardProps(Dynamic, shouldForwardProp);\r\n    const __base__ = Dynamic?.__base__ || Dynamic || \"div\";\r\n\r\n    const DreamyComponent = /* @__PURE__ */ forwardRef<any, any>(\r\n        function DreamyComponent(props, ref) {\r\n            const { as: Element = __base__, unstyled, children, ...restProps } = props;\r\n\r\n            // Ensure Element is always valid\r\n            const ValidElement = Element || __base__ || \"div\";\r\n\r\n            // biome-ignore lint/correctness/useExhaustiveDependencies: <explanation>\r\n            const combinedProps = useMemo(\r\n                () => Object.assign({}, defaultProps, restProps),\r\n                [...objectToDeps(restProps)]\r\n            );\r\n\r\n            const [htmlProps, forwardedProps, variantProps, styleProps, elementProps] =\r\n                useMemo(() => {\r\n                    return splitProps(\r\n                        combinedProps,\r\n                        normalizeHTMLProps.keys,\r\n                        __shouldForwardProps__,\r\n                        __cvaFn__.variantKeys,\r\n                        isCssProperty\r\n                    );\r\n                }, [combinedProps]);\r\n\r\n            function recipeClass() {\r\n                const { css: cssStyles, ...propStyles } = styleProps as any;\r\n                const compoundVariantStyles = __cvaFn__.__getCompoundVariantCss__?.(variantProps);\r\n                return cx(\r\n                    __cvaFn__(variantProps, false),\r\n                    css(compoundVariantStyles, propStyles, cssStyles),\r\n                    combinedProps.className\r\n                );\r\n            }\r\n\r\n            function cvaClass() {\r\n                const { css: cssStyles, ...propStyles } = styleProps as any;\r\n                const cvaStyles = __cvaFn__.raw(variantProps);\r\n                return cx(css(cvaStyles, propStyles, cssStyles), combinedProps.className);\r\n            }\r\n\r\n            const classes = () => {\r\n                if (unstyled) {\r\n                    const { css: cssStyles, ...propStyles } = styleProps as any;\r\n                    return cx(css(propStyles, cssStyles), combinedProps.className);\r\n                }\r\n                return configOrCva.__recipe__ ? recipeClass() : cvaClass();\r\n            };\r\n\r\n            return createElement(\r\n                ValidElement,\r\n                {\r\n                    ref,\r\n                    ...forwardedProps,\r\n                    ...elementProps,\r\n                    ...normalizeHTMLProps(htmlProps),\r\n                    className: classes()\r\n                },\r\n                children ?? combinedProps.children\r\n            );\r\n        }\r\n    );\r\n\r\n    const name = getDisplayName(__base__);\r\n\r\n    DreamyComponent.displayName = `dreamy.${name}`;\r\n    (DreamyComponent as any).__cva__ = __cvaFn__;\r\n    (DreamyComponent as any).__base__ = __base__;\r\n    (DreamyComponent as any).__shouldForwardProps__ = shouldForwardProp;\r\n\r\n    return DreamyComponent;\r\n}\r\n\r\n//\r\n//\r\n//\r\n//\r\n//\r\n//\r\n//\r\n//\r\n//\r\n//\r\n//\r\n//\r\n//\r\n//\r\n//\r\n//\r\n//\r\n//\r\n//\r\n//\r\n//\r\n//\r\n//\r\n//\r\n//\r\n//\r\n//\r\n//\r\n//\r\n//\r\n//\r\n//\r\n//\r\n//\r\n//\r\n//\r\n//\r\n//\r\n//\r\n//\r\n//\r\n//\r\n//\r\n//\r\n\r\nexport type JsxElement<T extends ElementType, P extends Dict> = T extends DreamyComponent<\r\n    infer A,\r\n    infer B\r\n>\r\n    ? DreamyComponent<A, Pretty<DistributiveUnion<P, B>>>\r\n    : DreamyComponent<T, P>;\r\n\r\ninterface DreamFactory {\r\n    <T extends ElementType>(component: T): DreamyComponent<T, {}>;\r\n    <T extends ElementType, P extends RecipeVariantRecord>(\r\n        component: T,\r\n        recipe: RecipeDefinition<P>,\r\n        options?: JsxFactoryOptions<JsxRecipeProps<T, RecipeSelection<P>>>\r\n    ): JsxElement<T, RecipeSelection<P>>;\r\n    <T extends ElementType, P extends RecipeFn>(\r\n        component: T,\r\n        recipeFn: P,\r\n        options?: JsxFactoryOptions<JsxRecipeProps<T, P[\"__type\"]>>\r\n    ): JsxElement<T, P[\"__type\"]>;\r\n}\r\n\r\ntype JsxElements = {\r\n    [K in keyof React.JSX.IntrinsicElements]: DreamyComponent<K, {}>;\r\n};\r\n\r\nexport type Dreamy = DreamFactory & JsxElements;\r\n\r\n// function styledWithAsProps<T extends ElementType, P extends RecipeVariantRecord>(\r\n//     Component: T,\r\n//     recipe?: RecipeDefinition<P>,\r\n//     options?: JsxFactoryOptions<JsxRecipeProps<T, RecipeSelection<P>>>\r\n// ): DreamyComponent<T, {}>;\r\n// function styledWithAsProps<T extends ElementType, P extends RecipeFn>(\r\n//     Component: T,\r\n//     recipe?: P,\r\n//     options?: JsxFactoryOptions<JsxRecipeProps<T, P[\"__type\"]>>\r\n// ): DreamyComponent<T, P[\"__type\"]> {\r\n//     return styledFn(Component, recipe as any, options) as any;\r\n// }\r\n\r\nfunction createJsxFactory() {\r\n    const cache = new Map<DOMElements, DreamyComponent<DOMElements>>();\r\n\r\n    return new Proxy(styledFn, {\r\n        apply(\r\n            _,\r\n            __,\r\n            args: [\r\n                DOMElements,\r\n                RecipeDefinition<RecipeVariantRecord>,\r\n                JsxFactoryOptions<JsxRecipeProps<DOMElements, RecipeSelection<RecipeVariantRecord>>>\r\n            ]\r\n        ) {\r\n            return styledFn(...args);\r\n        },\r\n        get(_, el: DOMElements) {\r\n            if (!el) {\r\n                return undefined;\r\n            }\r\n            if (!cache.has(el)) {\r\n                const comp = styledFn(el, undefined, undefined);\r\n                cache.set(el, comp);\r\n                return comp;\r\n            }\r\n            return cache.get(el)!;\r\n        }\r\n    }) as unknown as Dreamy;\r\n}\r\n\r\nexport const dreamy = createJsxFactory();\r\n\r\nexport function getRef(child: React.ReactElement) {\r\n    if (\"ref\" in (child?.props as object)) return (child.props as { ref: React.Ref<unknown> }).ref;\r\n    if (\"ref\" in child) return child.ref;\r\n    return null;\r\n}\r\n\r\ntype PossibleRef<T> = React.Ref<T> | unknown | undefined;\r\n\r\nexport function setRef<T>(ref: PossibleRef<T>, value: T) {\r\n    if (typeof ref === \"function\") {\r\n        ref(value);\r\n    } else if (ref !== null && ref !== undefined) {\r\n        (ref as React.MutableRefObject<T>).current = value;\r\n    }\r\n}\r\n\r\nexport function composeRefs<T>(...refs: PossibleRef<T>[]) {\r\n    return (node: T) => {\r\n        for (const ref of refs) {\r\n            setRef(ref, node);\r\n        }\r\n    };\r\n}\r\n\r\ninterface HtmlProps {\r\n    htmlSize?: number;\r\n    htmlWidth?: string | number;\r\n    htmlHeight?: string | number;\r\n    htmlTranslate?: \"yes\" | \"no\" | undefined;\r\n    htmlContent?: string;\r\n}\r\n\r\nexport type HtmlProp =\r\n    | \"color\"\r\n    | \"size\"\r\n    | \"translate\"\r\n    | \"transition\"\r\n    | \"width\"\r\n    | \"height\"\r\n    | \"content\";\r\n\r\nexport interface PolymorphicProps {\r\n    as?: ElementType;\r\n    asChild?: boolean;\r\n    asComp?: React.ReactNode;\r\n}\r\n\r\ntype PatchHtmlProps<T> = DistributiveOmit<T, HtmlProp> & HtmlProps;\r\n\r\ntype AssignHtmlProps<T extends Dict, P extends Dict = {}> = Assign<PatchHtmlProps<T>, P>;\r\n\r\ntype DataAttrProps = {\r\n    [K in `data-${string}`]?: string;\r\n};\r\n\r\ntype AriaAttrProps = {\r\n    [K in `aria-${string}`]?: string;\r\n};\r\n\r\nexport type HTMLDreamyProps<T extends ElementType, P extends Dict = {}> = AssignHtmlProps<\r\n    ComponentPropsWithoutRef<T>,\r\n    Assign<JsxStyleProps, P> & PolymorphicProps & UnstyledProps & DataAttrProps & AriaAttrProps\r\n>;\r\n\r\nexport type AnyFunction<T = any> = (...args: T[]) => any;\r\n\r\nexport type Merge<M, N> = N extends Record<string, unknown> ? M : Omit<M, keyof N> & N;\r\n\r\nexport interface FocusableElement {\r\n    focus(options?: FocusOptions): void;\r\n}\r\n\r\nexport type Dict<T = any> = Record<string, T>;\r\n\r\nexport type DOMElements = keyof React.JSX.IntrinsicElements;\r\n\r\nexport type HTMLDreamyComponents = {\r\n    [Tag in DOMElements]: DreamyComponent<React.ComponentType<Tag>, {}>;\r\n};\r\n\r\nexport type DreamyComponent<T extends ElementType, P extends Dict = {}> = FunctionComponent<\r\n    HTMLDreamyProps<T, P> & { ref?: any }\r\n>;\r\n\r\nexport type Status = \"info\" | \"warning\" | \"error\" | \"success\";\r\n"
  },
  "component": "Factory",
  "hasRecipe": false,
  "hasPattern": false
}