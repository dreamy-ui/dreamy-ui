{
  "type": "component",
  "fileDependencies": [],
  "id": "factory",
  "file": {
    "name": "factory.ts",
    "content": "import type React from \"react\";\r\nimport {\r\n\tChildren,\r\n\ttype ComponentPropsWithoutRef,\r\n\ttype ElementType,\r\n\ttype FunctionComponent,\r\n\tcloneElement,\r\n\tcreateElement,\r\n\tforwardRef,\r\n\tisValidElement,\r\n\tmemo\r\n} from \"react\";\r\nimport { styled } from \"styled-system/jsx\";\r\nimport type {\r\n\tAssign,\r\n\tDistributiveOmit,\r\n\tDistributiveUnion,\r\n\tJsxRecipeProps,\r\n\tJsxStyleProps,\r\n\tPretty,\r\n\tRecipeDefinition,\r\n\tRecipeSelection,\r\n\tRecipeVariantRecord\r\n} from \"styled-system/types\";\r\n\r\ntype DreamPropsWithRef<E extends React.ElementType> =\r\n\tReact.ComponentPropsWithRef<E>;\r\n\r\ninterface RecipeFn {\r\n\t__type: any;\r\n}\r\n\r\ninterface JsxFactoryOptions<TProps extends Dict> {\r\n\tdataAttr?: boolean;\r\n\tdefaultProps?: TProps;\r\n\tshouldForwardProp?(prop: string, variantKeys: string[]): boolean;\r\n}\r\n\r\nfunction withAsProps(Component: React.ElementType) {\r\n\tconst Comp = memo(\r\n\t\tforwardRef<unknown, DreamPropsWithRef<typeof Component>>(\r\n\t\t\t(props: DreamPropsWithRef<typeof Component>, ref) => {\r\n\t\t\t\tconst { asChild, asComp, children, ...restProps } = props;\r\n\r\n\t\t\t\tif (asComp) {\r\n\t\t\t\t\treturn createElement(\r\n\t\t\t\t\t\tasComp.type,\r\n\t\t\t\t\t\t{\r\n\t\t\t\t\t\t\t...restProps,\r\n\t\t\t\t\t\t\t...asComp.props,\r\n\t\t\t\t\t\t\tref:\r\n\t\t\t\t\t\t\t\t\"ref\" in asComp\r\n\t\t\t\t\t\t\t\t\t? composeRefs(ref, asComp.ref)\r\n\t\t\t\t\t\t\t\t\t: ref\r\n\t\t\t\t\t\t},\r\n\t\t\t\t\t\tchildren\r\n\t\t\t\t\t);\r\n\t\t\t\t}\r\n\r\n\t\t\t\tif (!asChild) {\r\n\t\t\t\t\treturn createElement(\r\n\t\t\t\t\t\tComponent,\r\n\t\t\t\t\t\t{ ...restProps, ref },\r\n\t\t\t\t\t\tchildren\r\n\t\t\t\t\t);\r\n\t\t\t\t}\r\n\r\n\t\t\t\tconst onlyChild = Children.only(children) as React.ReactElement;\r\n\r\n\t\t\t\tif (!isValidElement(onlyChild)) {\r\n\t\t\t\t\treturn null;\r\n\t\t\t\t}\r\n\r\n\t\t\t\tconst childRef = getRef(onlyChild);\r\n\r\n\t\t\t\treturn cloneElement(onlyChild, {\r\n\t\t\t\t\t...restProps,\r\n\t\t\t\t\t...(onlyChild.props as object),\r\n\t\t\t\t\tref: ref ? composeRefs(ref, childRef) : childRef\r\n\t\t\t\t});\r\n\t\t\t}\r\n\t\t)\r\n\t);\r\n\r\n\t// @ts-expect-error - it exists\r\n\tComp.displayName = Component.displayName || Component.name;\r\n\r\n\treturn Comp;\r\n}\r\n\r\nexport type JsxElement<\r\n\tT extends ElementType,\r\n\tP extends Dict\r\n> = T extends DreamyComponent<infer A, infer B>\r\n\t? DreamyComponent<A, Pretty<DistributiveUnion<P, B>>>\r\n\t: DreamyComponent<T, P>;\r\n\r\ninterface DreamFactory {\r\n\t<T extends ElementType>(component: T): DreamyComponent<T, {}>;\r\n\t<T extends ElementType, P extends RecipeVariantRecord>(\r\n\t\tcomponent: T,\r\n\t\trecipe: RecipeDefinition<P>,\r\n\t\toptions?: JsxFactoryOptions<JsxRecipeProps<T, RecipeSelection<P>>>\r\n\t): JsxElement<T, RecipeSelection<P>>;\r\n\t<T extends ElementType, P extends RecipeFn>(\r\n\t\tcomponent: T,\r\n\t\trecipeFn: P,\r\n\t\toptions?: JsxFactoryOptions<JsxRecipeProps<T, P[\"__type\"]>>\r\n\t): JsxElement<T, P[\"__type\"]>;\r\n}\r\n\r\ntype JsxElements = {\r\n\t[K in keyof React.JSX.IntrinsicElements]: DreamyComponent<K, {}>;\r\n};\r\n\r\nexport type Dreamy = DreamFactory & JsxElements;\r\n\r\nfunction styledWithAsProps<\r\n\tT extends ElementType,\r\n\tP extends RecipeVariantRecord\r\n>(\r\n\tComponent: T,\r\n\trecipe?: RecipeDefinition<P>,\r\n\toptions?: JsxFactoryOptions<JsxRecipeProps<T, RecipeSelection<P>>>\r\n): DreamyComponent<T, {}>;\r\nfunction styledWithAsProps<T extends ElementType, P extends RecipeFn>(\r\n\tComponent: T,\r\n\trecipe?: P,\r\n\toptions?: JsxFactoryOptions<JsxRecipeProps<T, P[\"__type\"]>>\r\n): DreamyComponent<T, P[\"__type\"]> {\r\n\treturn styled(withAsProps(Component), recipe as any, options) as any;\r\n}\r\n\r\nfunction createJsxFactory() {\r\n\tconst cache = new Map<DOMElements, DreamyComponent<DOMElements>>();\r\n\r\n\treturn new Proxy(styledWithAsProps, {\r\n\t\tapply(\r\n\t\t\t_,\r\n\t\t\t__,\r\n\t\t\targs: [\r\n\t\t\t\tDOMElements,\r\n\t\t\t\tRecipeDefinition<RecipeVariantRecord>,\r\n\t\t\t\tJsxFactoryOptions<\r\n\t\t\t\t\tJsxRecipeProps<\r\n\t\t\t\t\t\tDOMElements,\r\n\t\t\t\t\t\tRecipeSelection<RecipeVariantRecord>\r\n\t\t\t\t\t>\r\n\t\t\t\t>\r\n\t\t\t]\r\n\t\t) {\r\n\t\t\treturn styledWithAsProps(...args);\r\n\t\t},\r\n\t\tget(_, el: DOMElements) {\r\n\t\t\tif (!cache.has(el)) {\r\n\t\t\t\tcache.set(el, styledWithAsProps(el, undefined, undefined));\r\n\t\t\t}\r\n\t\t\treturn cache.get(el);\r\n\t\t}\r\n\t}) as unknown as Dreamy;\r\n}\r\n\r\nexport const dreamy = createJsxFactory();\r\n\r\nexport function getRef(child: React.ReactElement) {\r\n\tif (\"ref\" in (child?.props as object))\r\n\t\treturn (child.props as { ref: React.Ref<unknown> }).ref;\r\n\tif (\"ref\" in child) return child.ref;\r\n\treturn null;\r\n}\r\n\r\ntype PossibleRef<T> = React.Ref<T> | unknown | undefined;\r\n\r\nexport function setRef<T>(ref: PossibleRef<T>, value: T) {\r\n\tif (typeof ref === \"function\") {\r\n\t\tref(value);\r\n\t} else if (ref !== null && ref !== undefined) {\r\n\t\t(ref as React.MutableRefObject<T>).current = value;\r\n\t}\r\n}\r\n\r\nexport function composeRefs<T>(...refs: PossibleRef<T>[]) {\r\n\treturn (node: T) => {\r\n\t\tfor (const ref of refs) {\r\n\t\t\tsetRef(ref, node);\r\n\t\t}\r\n\t};\r\n}\r\n\r\ninterface HtmlProps {\r\n\thtmlSize?: number;\r\n\thtmlWidth?: string | number;\r\n\thtmlHeight?: string | number;\r\n\thtmlTranslate?: \"yes\" | \"no\" | undefined;\r\n\thtmlContent?: string;\r\n}\r\n\r\nexport type HtmlProp =\r\n\t| \"color\"\r\n\t| \"size\"\r\n\t| \"translate\"\r\n\t| \"transition\"\r\n\t| \"width\"\r\n\t| \"height\"\r\n\t| \"content\";\r\n\r\nexport interface PolymorphicProps {\r\n\tas?: ElementType;\r\n\tasChild?: boolean;\r\n\tasComp?: React.ReactNode;\r\n}\r\n\r\ntype PatchHtmlProps<T> = DistributiveOmit<T, HtmlProp> & HtmlProps;\r\n\r\ntype AssignHtmlProps<T extends Dict, P extends Dict = {}> = Assign<\r\n\tPatchHtmlProps<T>,\r\n\tP\r\n>;\r\n\r\nexport type HTMLDreamyProps<\r\n\tT extends ElementType,\r\n\tP extends Dict = {}\r\n> = AssignHtmlProps<\r\n\tComponentPropsWithoutRef<T>,\r\n\tAssign<JsxStyleProps, P> & PolymorphicProps\r\n>;\r\n\r\nexport type AnyFunction<T = any> = (...args: T[]) => any;\r\n\r\nexport type Merge<M, N> = N extends Record<string, unknown>\r\n\t? M\r\n\t: Omit<M, keyof N> & N;\r\n\r\nexport interface FocusableElement {\r\n\tfocus(options?: FocusOptions): void;\r\n}\r\n\r\nexport type Dict<T = any> = Record<string, T>;\r\n\r\nexport type DOMElements = keyof React.JSX.IntrinsicElements;\r\n\r\nexport type HTMLDreamyComponents = {\r\n\t[Tag in DOMElements]: DreamyComponent<React.ComponentType<Tag>, {}>;\r\n};\r\n\r\nexport type DreamyComponent<\r\n\tT extends ElementType,\r\n\tP extends Dict = {}\r\n> = FunctionComponent<HTMLDreamyProps<T, P> & { ref?: any }>;\r\n\r\nexport type Status = \"info\" | \"warning\" | \"error\" | \"success\";\r\n"
  },
  "component": "Factory",
  "hasRecipe": false,
  "hasPattern": false
}