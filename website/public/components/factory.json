{
  "type": "component",
  "fileDependencies": [],
  "id": "factory",
  "file": {
    "name": "factory.ts",
    "content": "import type React from \"react\";\r\nimport {\r\n    Children,\r\n    type ComponentPropsWithoutRef,\r\n    type ElementType,\r\n    type FunctionComponent,\r\n    cloneElement,\r\n    createElement,\r\n    forwardRef,\r\n    isValidElement,\r\n    memo\r\n} from \"react\";\r\nimport { dreamy as styled } from \"styled-system/jsx\";\r\nimport type {\r\n    Assign,\r\n    DistributiveOmit,\r\n    DistributiveUnion,\r\n    JsxRecipeProps,\r\n    JsxStyleProps,\r\n    Pretty,\r\n    RecipeDefinition,\r\n    RecipeSelection,\r\n    RecipeVariantRecord,\r\n    UnstyledProps\r\n} from \"styled-system/types\";\r\n\r\ntype DreamPropsWithRef<E extends React.ElementType> = React.ComponentPropsWithRef<E>;\r\n\r\ninterface RecipeFn {\r\n    __type: any;\r\n}\r\n\r\ninterface JsxFactoryOptions<TProps extends Dict> {\r\n    dataAttr?: boolean;\r\n    defaultProps?: TProps;\r\n    shouldForwardProp?(prop: string, variantKeys: string[]): boolean;\r\n}\r\n\r\nfunction withAsProps(Component: React.ElementType) {\r\n    const Comp = memo(\r\n        forwardRef<unknown, DreamPropsWithRef<typeof Component>>(\r\n            (props: DreamPropsWithRef<typeof Component>, ref) => {\r\n                const { asChild, asComp, children, ...restProps } = props;\r\n\r\n                if (asComp) {\r\n                    return createElement(\r\n                        asComp.type,\r\n                        {\r\n                            ...restProps,\r\n                            ...asComp.props,\r\n                            ref: \"ref\" in asComp ? composeRefs(ref, asComp.ref) : ref\r\n                        },\r\n                        children\r\n                    );\r\n                }\r\n\r\n                if (!asChild) {\r\n                    return createElement(Component, { ...restProps, ref }, children);\r\n                }\r\n\r\n                const onlyChild = Children.only(children) as React.ReactElement;\r\n\r\n                if (!isValidElement(onlyChild)) {\r\n                    return null;\r\n                }\r\n\r\n                const childRef = getRef(onlyChild);\r\n\r\n                return cloneElement(onlyChild, {\r\n                    ...restProps,\r\n                    ...(onlyChild.props as object),\r\n                    ref: ref ? composeRefs(ref, childRef) : childRef\r\n                });\r\n            }\r\n        )\r\n    );\r\n\r\n    // @ts-expect-error - it exists\r\n    Comp.displayName = Component.displayName || Component.name;\r\n\r\n    return Comp;\r\n}\r\n\r\nexport type JsxElement<T extends ElementType, P extends Dict> = T extends DreamyComponent<\r\n    infer A,\r\n    infer B\r\n>\r\n    ? DreamyComponent<A, Pretty<DistributiveUnion<P, B>>>\r\n    : DreamyComponent<T, P>;\r\n\r\ninterface DreamFactory {\r\n    <T extends ElementType>(component: T): DreamyComponent<T, {}>;\r\n    <T extends ElementType, P extends RecipeVariantRecord>(\r\n        component: T,\r\n        recipe: RecipeDefinition<P>,\r\n        options?: JsxFactoryOptions<JsxRecipeProps<T, RecipeSelection<P>>>\r\n    ): JsxElement<T, RecipeSelection<P>>;\r\n    <T extends ElementType, P extends RecipeFn>(\r\n        component: T,\r\n        recipeFn: P,\r\n        options?: JsxFactoryOptions<JsxRecipeProps<T, P[\"__type\"]>>\r\n    ): JsxElement<T, P[\"__type\"]>;\r\n}\r\n\r\ntype JsxElements = {\r\n    [K in keyof React.JSX.IntrinsicElements]: DreamyComponent<K, {}>;\r\n};\r\n\r\nexport type Dreamy = DreamFactory & JsxElements;\r\n\r\nfunction styledWithAsProps<T extends ElementType, P extends RecipeVariantRecord>(\r\n    Component: T,\r\n    recipe?: RecipeDefinition<P>,\r\n    options?: JsxFactoryOptions<JsxRecipeProps<T, RecipeSelection<P>>>\r\n): DreamyComponent<T, {}>;\r\nfunction styledWithAsProps<T extends ElementType, P extends RecipeFn>(\r\n    Component: T,\r\n    recipe?: P,\r\n    options?: JsxFactoryOptions<JsxRecipeProps<T, P[\"__type\"]>>\r\n): DreamyComponent<T, P[\"__type\"]> {\r\n    return styled(withAsProps(Component), recipe as any, options) as any;\r\n}\r\n\r\nfunction createJsxFactory() {\r\n    const cache = new Map<DOMElements, DreamyComponent<DOMElements>>();\r\n\r\n    return new Proxy(styledWithAsProps, {\r\n        apply(\r\n            _,\r\n            __,\r\n            args: [\r\n                DOMElements,\r\n                RecipeDefinition<RecipeVariantRecord>,\r\n                JsxFactoryOptions<JsxRecipeProps<DOMElements, RecipeSelection<RecipeVariantRecord>>>\r\n            ]\r\n        ) {\r\n            return styledWithAsProps(...args);\r\n        },\r\n        get(_, el: DOMElements) {\r\n            if (!cache.has(el)) {\r\n                cache.set(el, styledWithAsProps(el, undefined, undefined));\r\n            }\r\n            return cache.get(el);\r\n        }\r\n    }) as unknown as Dreamy;\r\n}\r\n\r\nexport const dreamy = createJsxFactory();\r\n\r\nexport function getRef(child: React.ReactElement) {\r\n    if (\"ref\" in (child?.props as object)) return (child.props as { ref: React.Ref<unknown> }).ref;\r\n    if (\"ref\" in child) return child.ref;\r\n    return null;\r\n}\r\n\r\ntype PossibleRef<T> = React.Ref<T> | unknown | undefined;\r\n\r\nexport function setRef<T>(ref: PossibleRef<T>, value: T) {\r\n    if (typeof ref === \"function\") {\r\n        ref(value);\r\n    } else if (ref !== null && ref !== undefined) {\r\n        (ref as React.MutableRefObject<T>).current = value;\r\n    }\r\n}\r\n\r\nexport function composeRefs<T>(...refs: PossibleRef<T>[]) {\r\n    return (node: T) => {\r\n        for (const ref of refs) {\r\n            setRef(ref, node);\r\n        }\r\n    };\r\n}\r\n\r\ninterface HtmlProps {\r\n    htmlSize?: number;\r\n    htmlWidth?: string | number;\r\n    htmlHeight?: string | number;\r\n    htmlTranslate?: \"yes\" | \"no\" | undefined;\r\n    htmlContent?: string;\r\n}\r\n\r\nexport type HtmlProp =\r\n    | \"color\"\r\n    | \"size\"\r\n    | \"translate\"\r\n    | \"transition\"\r\n    | \"width\"\r\n    | \"height\"\r\n    | \"content\";\r\n\r\nexport interface PolymorphicProps {\r\n    as?: ElementType;\r\n    asChild?: boolean;\r\n    asComp?: React.ReactNode;\r\n}\r\n\r\ntype PatchHtmlProps<T> = DistributiveOmit<T, HtmlProp> & HtmlProps;\r\n\r\ntype AssignHtmlProps<T extends Dict, P extends Dict = {}> = Assign<PatchHtmlProps<T>, P>;\r\n\r\ntype DataAttrProps = {\r\n    [K in `data-${string}`]?: string;\r\n};\r\n\r\ntype AriaAttrProps = {\r\n    [K in `aria-${string}`]?: string;\r\n};\r\n\r\nexport type HTMLDreamyProps<T extends ElementType, P extends Dict = {}> = AssignHtmlProps<\r\n    ComponentPropsWithoutRef<T>,\r\n    Assign<JsxStyleProps, P> & PolymorphicProps & UnstyledProps & DataAttrProps & AriaAttrProps\r\n>;\r\n\r\nexport type AnyFunction<T = any> = (...args: T[]) => any;\r\n\r\nexport type Merge<M, N> = N extends Record<string, unknown> ? M : Omit<M, keyof N> & N;\r\n\r\nexport interface FocusableElement {\r\n    focus(options?: FocusOptions): void;\r\n}\r\n\r\nexport type Dict<T = any> = Record<string, T>;\r\n\r\nexport type DOMElements = keyof React.JSX.IntrinsicElements;\r\n\r\nexport type HTMLDreamyComponents = {\r\n    [Tag in DOMElements]: DreamyComponent<React.ComponentType<Tag>, {}>;\r\n};\r\n\r\nexport type DreamyComponent<T extends ElementType, P extends Dict = {}> = FunctionComponent<\r\n    HTMLDreamyProps<T, P> & { ref?: any }\r\n>;\r\n\r\nexport type Status = \"info\" | \"warning\" | \"error\" | \"success\";\r\n"
  },
  "component": "Factory",
  "hasRecipe": false,
  "hasPattern": false
}