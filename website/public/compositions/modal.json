{
  "type": "composition",
  "fileDependencies": [
    "./box",
    "./close-button",
    "./flex",
    "./heading",
    "./motion",
    "./style-context"
  ],
  "id": "modal",
  "file": {
    "name": "modal.tsx",
    "content": "\"use client\";\n\nimport {\n\tFocusLock,\n\tModalContextProvider,\n\tPortal,\n\tPortalProps,\n\tRemoveScroll,\n\tuseDefaultTransition,\n\tuseModal,\n\tuseModalContext,\n\tUseModalProps,\n\tUseModalReturn,\n\tuseMotionVariants\n} from \"@dreamy-ui/react\";\nimport { AnimatePresence, usePresence } from \"motion/react\";\nimport { forwardRef, RefObject, useEffect, useMemo, useState } from \"react\";\nimport { modal } from \"styled-system/recipes\";\nimport { Box, BoxProps } from \"./box\";\nimport { CloseButton, CloseButtonProps } from \"./close-button\";\nimport { Flex, FlexProps } from \"./flex\";\nimport { Heading } from \"./heading\";\nimport {\n\tMotionBox,\n\tMotionBoxProps,\n\tMotionFlex,\n\tMotionFlexProps\n} from \"./motion\";\nimport { createStyleContext } from \"./style-context\";\n\nconst { withProvider, withContext } = createStyleContext(modal);\n\ninterface ModalContext extends ModalOptions, UseModalReturn {\n\tscrollBehavior?: \"inside\" | \"outside\";\n}\n\n/**\n * Modal component\n *\n * @See Docs https://dreamy-ui.com/docs/components/modal\n */\nexport const Modal = withProvider(function ModalRoot(props: ModalProps) {\n\tconst modalProps: ModalProps = {\n\t\tscrollBehavior: \"inside\",\n\t\tautoFocus: true,\n\t\ttrapFocus: true,\n\t\treturnFocusOnClose: true,\n\t\tblockScrollOnMount: true,\n\t\tallowPinchZoom: false,\n\t\tpreserveScrollBarGap: true,\n\t\t...props\n\t};\n\n\tconst {\n\t\tchildren,\n\t\tautoFocus,\n\t\ttrapFocus,\n\t\tinitialFocusRef,\n\t\tfinalFocusRef,\n\t\treturnFocusOnClose,\n\t\tblockScrollOnMount,\n\t\tscrollBehavior,\n\t\tallowPinchZoom,\n\t\tpreserveScrollBarGap,\n\t\tonCloseComplete,\n\t\tportalProps\n\t} = modalProps;\n\n\tconst modal = useModal(modalProps);\n\n\t// biome-ignore lint/correctness/useExhaustiveDependencies: <explanation>\n\tconst context = useMemo(() => {\n\t\treturn {\n\t\t\t...modal,\n\t\t\tautoFocus,\n\t\t\ttrapFocus,\n\t\t\tinitialFocusRef,\n\t\t\tfinalFocusRef,\n\t\t\treturnFocusOnClose,\n\t\t\tblockScrollOnMount,\n\t\t\tallowPinchZoom,\n\t\t\tpreserveScrollBarGap,\n\t\t\tonCloseComplete,\n\t\t\tscrollBehavior\n\t\t};\n\t}, [modal]);\n\n\treturn (\n\t\t<ModalContextProvider value={context}>\n\t\t\t<AnimatePresence onExitComplete={onCloseComplete}>\n\t\t\t\t{context.isOpen && (\n\t\t\t\t\t<Portal key={context.id} {...portalProps}>\n\t\t\t\t\t\t{children}\n\t\t\t\t\t</Portal>\n\t\t\t\t)}\n\t\t\t</AnimatePresence>\n\t\t</ModalContextProvider>\n\t);\n});\n\nexport interface ModalOverlayProps extends MotionBoxProps {}\n\nexport const ModalOverlay = withContext(\n\tforwardRef<HTMLDivElement, ModalOverlayProps>((props, ref) => {\n\t\tconst { isOpen } = useModalContext();\n\t\tconst { overlay } = useMotionVariants();\n\n\t\treturn (\n\t\t\t<AnimatePresence>\n\t\t\t\t{isOpen && (\n\t\t\t\t\t<MotionBox\n\t\t\t\t\t\tvariants={overlay.default}\n\t\t\t\t\t\tinitial=\"initial\"\n\t\t\t\t\t\tanimate=\"animate\"\n\t\t\t\t\t\texit=\"exit\"\n\t\t\t\t\t\tref={ref}\n\t\t\t\t\t\t{...props}\n\t\t\t\t\t/>\n\t\t\t\t)}\n\t\t\t</AnimatePresence>\n\t\t);\n\t}),\n\t\"overlay\"\n);\n\nexport interface ModalContainerProps extends MotionFlexProps {}\n\nexport const ModalContainer = withContext(\n\tforwardRef<HTMLDivElement, BoxProps>(({ children, ...props }, ref) => {\n\t\tconst { getDialogContainerProps } = useModalContext();\n\n\t\treturn <Box {...getDialogContainerProps(props, ref)}>{children}</Box>;\n\t}),\n\t\"container\"\n);\n\nexport interface ModalContentProps extends MotionFlexProps {}\n\nexport const ModalContent = withContext(\n\tforwardRef<HTMLDivElement, MotionFlexProps>(\n\t\t({ children, ...props }, ref) => {\n\t\t\tconst { getDialogProps } = useModalContext();\n\t\t\tconst { modal } = useMotionVariants();\n\t\t\tconst transition = useDefaultTransition();\n\n\t\t\treturn (\n\t\t\t\t<>\n\t\t\t\t\t<ModalFocusScope>\n\t\t\t\t\t\t<ModalContainer>\n\t\t\t\t\t\t\t<MotionFlex\n\t\t\t\t\t\t\t\tvariants={modal.default}\n\t\t\t\t\t\t\t\tinitial=\"initial\"\n\t\t\t\t\t\t\t\tanimate=\"animate\"\n\t\t\t\t\t\t\t\texit=\"exit\"\n\t\t\t\t\t\t\t\ttransition={transition}\n\t\t\t\t\t\t\t\t{...(getDialogProps(props as any, ref) as any)}\n\t\t\t\t\t\t\t>\n\t\t\t\t\t\t\t\t{children}\n\t\t\t\t\t\t\t</MotionFlex>\n\t\t\t\t\t\t</ModalContainer>\n\t\t\t\t\t</ModalFocusScope>\n\t\t\t\t</>\n\t\t\t);\n\t\t}\n\t),\n\t\"content\"\n);\n\nexport interface ModalHeaderProps extends FlexProps {}\n\nexport const ModalHeader = withContext(\n\tforwardRef<HTMLDivElement, ModalHeaderProps>(\n\t\t({ children, ...props }, ref) => {\n\t\t\treturn (\n\t\t\t\t<Flex as={\"header\"} {...props} ref={ref}>\n\t\t\t\t\t{typeof children === \"string\" ? (\n\t\t\t\t\t\t<Heading variant={\"heading\"} size=\"lg\">\n\t\t\t\t\t\t\t{children}\n\t\t\t\t\t\t</Heading>\n\t\t\t\t\t) : (\n\t\t\t\t\t\tchildren\n\t\t\t\t\t)}\n\t\t\t\t</Flex>\n\t\t\t);\n\t\t}\n\t),\n\t\"header\"\n);\n\nexport interface ModalBodyProps extends FlexProps {}\n\nexport const ModalBody = withContext(\n\tforwardRef<HTMLDivElement, ModalBodyProps>(\n\t\t({ children, style, ...props }, ref) => {\n\t\t\tconst { scrollBehavior } = useModalContext();\n\n\t\t\treturn (\n\t\t\t\t<Flex\n\t\t\t\t\tref={ref}\n\t\t\t\t\t{...props}\n\t\t\t\t\tstyle={{\n\t\t\t\t\t\tmaxHeight:\n\t\t\t\t\t\t\tscrollBehavior === \"inside\"\n\t\t\t\t\t\t\t\t? \"calc(100vh - 10rem)\"\n\t\t\t\t\t\t\t\t: undefined,\n\t\t\t\t\t\toverflow:\n\t\t\t\t\t\t\tscrollBehavior === \"inside\" ? \"auto\" : undefined,\n\t\t\t\t\t\t...style\n\t\t\t\t\t}}\n\t\t\t\t>\n\t\t\t\t\t{children}\n\t\t\t\t</Flex>\n\t\t\t);\n\t\t}\n\t),\n\t\"body\"\n);\n\nexport interface ModalFooterProps extends FlexProps {}\n\nexport const ModalFooter = withContext(\n\tforwardRef<HTMLDivElement, ModalFooterProps>(\n\t\t({ children, ...props }, ref) => {\n\t\t\treturn (\n\t\t\t\t<Flex as={\"footer\"} {...props} ref={ref}>\n\t\t\t\t\t{children}\n\t\t\t\t</Flex>\n\t\t\t);\n\t\t}\n\t),\n\t\"footer\"\n);\n\nexport interface ModalCloseButtonProps extends CloseButtonProps {}\n\nexport const ModalCloseButton = withContext(\n\tforwardRef<HTMLButtonElement, ModalCloseButtonProps>(\n\t\t({ ...props }, ref) => {\n\t\t\tconst { onClose } = useModalContext();\n\n\t\t\treturn <CloseButton ref={ref} onClick={onClose} {...props} />;\n\t\t}\n\t),\n\t\"close\"\n);\n\ninterface ModalFocusScopeProps {\n\tchildren: React.ReactElement;\n}\n\nclass ModalManager {\n\tmodals: Map<HTMLElement, number>;\n\tconstructor() {\n\t\tthis.modals = new Map();\n\t}\n\n\tadd(modal: HTMLElement) {\n\t\tthis.modals.set(modal, this.modals.size + 1);\n\t\treturn this.modals.size;\n\t}\n\n\tremove(modal: HTMLElement) {\n\t\tthis.modals.delete(modal);\n\t}\n\n\tisTopModal(modal: HTMLElement | null) {\n\t\tif (!modal) return false;\n\t\treturn this.modals.get(modal) === this.modals.size;\n\t}\n}\n\nexport const modalManager = new ModalManager();\n\nexport function useModalManager(\n\tref: RefObject<HTMLElement | null>,\n\tisOpen?: boolean\n) {\n\tconst [index, setIndex] = useState(0);\n\n\tuseEffect(() => {\n\t\tconst node = ref.current;\n\n\t\tif (!node) return;\n\n\t\tif (isOpen) {\n\t\t\tconst index = modalManager.add(node);\n\t\t\tsetIndex(index);\n\t\t}\n\n\t\treturn () => {\n\t\t\tmodalManager.remove(node);\n\t\t\tsetIndex(0);\n\t\t};\n\t}, [isOpen, ref]);\n\n\treturn index;\n}\n\nfunction ModalFocusScope(props: ModalFocusScopeProps) {\n\tconst {\n\t\tautoFocus,\n\t\ttrapFocus,\n\t\tdialogRef,\n\t\tinitialFocusRef,\n\t\tblockScrollOnMount,\n\t\tallowPinchZoom,\n\t\tfinalFocusRef,\n\t\treturnFocusOnClose,\n\t\tpreserveScrollBarGap,\n\t\tlockFocusAcrossFrames,\n\t\tuseInert,\n\t\tisOpen\n\t} = useModalContext();\n\n\tconst [isPresent, safeToRemove] = usePresence();\n\n\tuseEffect(() => {\n\t\tif (!isPresent && safeToRemove) {\n\t\t\tsetTimeout(safeToRemove);\n\t\t}\n\t}, [isPresent, safeToRemove]);\n\n\tconst index = useModalManager(dialogRef, isOpen);\n\n\treturn (\n\t\t<FocusLock\n\t\t\tautoFocus={autoFocus}\n\t\t\tisDisabled={!trapFocus}\n\t\t\tinitialFocusRef={initialFocusRef}\n\t\t\tfinalFocusRef={finalFocusRef}\n\t\t\trestoreFocus={returnFocusOnClose}\n\t\t\tcontentRef={dialogRef}\n\t\t\tlockFocusAcrossFrames={lockFocusAcrossFrames}\n\t\t>\n\t\t\t<RemoveScroll\n\t\t\t\tremoveScrollBar={!preserveScrollBarGap}\n\t\t\t\tallowPinchZoom={allowPinchZoom}\n\t\t\t\t// only block scroll for first dialog\n\t\t\t\tenabled={index === 1 && blockScrollOnMount}\n\t\t\t\tforwardProps\n\t\t\t\tinert={useInert}\n\t\t\t>\n\t\t\t\t{props.children}\n\t\t\t</RemoveScroll>\n\t\t</FocusLock>\n\t);\n}\n\nexport interface ModalProps extends UseModalProps, ModalOptions {\n\tchildren: React.ReactNode;\n\t/**\n\t * Where scroll behavior should originate.\n\t * - If set to `inside`, scroll only occurs within the `ModalBody`.\n\t * - If set to `outside`, the entire `ModalContent` will scroll within the viewport.\n\t *\n\t * @default \"outside\"\n\t */\n\tscrollBehavior?: ScrollBehavior;\n\t/**\n\t * Fires when all exiting nodes have completed animating out\n\t */\n\tonCloseComplete?: () => void;\n\t/**\n\t * Props to be forwarded to the portal component\n\t */\n\tportalProps?: PortalProps;\n}\n\ninterface ModalOptions {\n\t/**\n\t * If `false`, focus lock will be disabled completely.\n\t *\n\t * This is useful in situations where you still need to interact with\n\t * other surrounding elements.\n\t *\n\t * ðŸš¨Warning: We don't recommend doing this because it hurts the\n\t * accessibility of the modal, based on WAI-ARIA specifications.\n\t *\n\t * @default true\n\t */\n\ttrapFocus?: boolean;\n\t/**\n\t * If `true`, the modal will autofocus the first enabled and interactive\n\t * element within the `ModalContent`\n\t *\n\t * @default true\n\t */\n\tautoFocus?: boolean;\n\t/**\n\t * The `ref` of element to receive focus when the modal opens.\n\t */\n\tinitialFocusRef?: React.RefObject<FocusableElement | null>;\n\t/**\n\t * The `ref` of element to receive focus when the modal closes.\n\t */\n\tfinalFocusRef?: React.RefObject<FocusableElement | null>;\n\t/**\n\t * If `true`, the modal will return focus to the element that triggered it when it closes.\n\t * @default true\n\t */\n\treturnFocusOnClose?: boolean;\n\t/**\n\t * If `true`, scrolling will be disabled on the `body` when the modal opens.\n\t * @default true\n\t */\n\tblockScrollOnMount?: boolean;\n\t/**\n\t * Handle zoom/pinch gestures on iOS devices when scroll locking is enabled.\n\t * @default false.\n\t */\n\tallowPinchZoom?: boolean;\n\t/**\n\t * If `true`, a `padding-right` will be applied to the body element\n\t * that's equal to the width of the scrollbar.\n\t *\n\t * This can help prevent some unpleasant flickering effect\n\t * and content adjustment when the modal opens\n\t *\n\t * @default true\n\t */\n\tpreserveScrollBarGap?: boolean;\n\n\tlockFocusAcrossFrames?: boolean;\n}\n\ntype ScrollBehavior = \"inside\" | \"outside\";\n\nexport interface FocusLockProps {\n\t/**\n\t * `ref` of the element to receive focus initially\n\t */\n\tinitialFocusRef?: React.RefObject<FocusableElement | null>;\n\t/**\n\t * `ref` of the element to return focus to when `FocusLock`\n\t * unmounts\n\t */\n\tfinalFocusRef?: React.RefObject<FocusableElement | null>;\n\t/**\n\t * The `ref` of the wrapper for which the focus-lock wraps\n\t */\n\tcontentRef?: React.RefObject<HTMLElement>;\n\t/**\n\t * If `true`, focus will be restored to the element that\n\t * triggered the `FocusLock` once it unmounts\n\t *\n\t * @default false\n\t */\n\trestoreFocus?: boolean;\n\t/**\n\t * If `true`, focus trapping will be disabled\n\t *\n\t * @default false\n\t */\n\tdisabled?: boolean;\n\t/**\n\t * If `true`, the first focusable element within the `children`\n\t * will auto-focused once `FocusLock` mounts\n\t *\n\t * @default false\n\t */\n\tautoFocus?: boolean;\n\t/**\n\t * If `true`, disables text selections inside, and outside focus lock\n\t *\n\t * @default false\n\t */\n\tpersistentFocus?: boolean;\n}\n\ninterface FocusableElement {\n\tfocus(options?: FocusOptions): void;\n}\n"
  },
  "component": "Modal"
}